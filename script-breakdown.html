<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Script Breakdown - Checks Happy</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-dark: #0a0908;
            --bg-medium: rgba(18, 16, 14, 0.85);
            --card-bg: rgba(28, 25, 22, 0.5);
            --text-light: #e8e6e3;
            --text-muted: #9a8f7f;
            --accent-gold: #d4af7a;
            --accent-gold-hover: #e0c08f;
            --accent-blue: #667eea;
            --glass-border: rgba(255, 255, 255, 0.06);
            --glass-bg: rgba(20, 18, 16, 0.6);
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --success: #52c186;
            --error: #ff6b6b;
            --warning: #e8a87c;
            
            --int-day: rgba(255, 255, 255, 0.15);
            --ext-day: rgba(251, 191, 36, 0.15);
            --int-night: rgba(52, 211, 153, 0.15);
            --ext-night: rgba(56, 189, 248, 0.15);
            
            --int-day-border: rgba(255, 255, 255, 0.3);
            --ext-day-border: rgba(251, 191, 36, 0.4);
            --int-night-border: rgba(52, 211, 153, 0.4);
            --ext-night-border: rgba(56, 189, 248, 0.4);
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: rgba(13, 11, 10, 0.4); }
        ::-webkit-scrollbar-thumb { background: rgba(138, 127, 115, 0.3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(138, 127, 115, 0.5); }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #050404 0%, #0f0d0c 50%, #050404 100%);
            color: var(--text-light);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-layout { display: flex; height: 100vh; flex-direction: column; }
        
        .top-bar {
            height: 56px;
            background: 
                linear-gradient(to bottom, rgba(255, 255, 255, 0.03) 0%, transparent 100%),
                linear-gradient(135deg, rgba(212, 175, 122, 0.08) 0%, rgba(18, 16, 14, 0.85) 50%, rgba(212, 175, 122, 0.05) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 100;
            box-shadow: var(--shadow-sm), inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }
        
        .nav-section { display: flex; align-items: center; gap: 24px; }
        .back-link { display: flex; align-items: center; gap: 8px; color: var(--text-muted); cursor: pointer; font-size: 0.875em; text-decoration: none; transition: color 0.2s ease; }
        .back-link:hover { color: var(--accent-gold); }
        .page-title { font-size: 1.125em; font-weight: 600; }
        
        .toolbar { display: flex; gap: 8px; align-items: center; }
        .toolbar-btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8125em;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .toolbar-btn:hover { border-color: var(--accent-gold); color: var(--accent-gold); background: rgba(201, 169, 97, 0.05); }

        .auto-save-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 6px;
            color: #4ade80;
            font-size: 0.75em;
            font-weight: 500;
            animation: fadeInOut 1.5s ease-in-out;
        }

        .auto-save-indicator .save-icon {
            font-size: 1.1em;
            font-weight: 700;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-4px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-4px); }
        }
        
        .main-content { display: flex; flex: 1; overflow: hidden; }
        
        /* Left Sidebar - Scenes */
        .left-sidebar {
            width: 340px;
            background: 
                linear-gradient(to right, rgba(255, 255, 255, 0.02) 0%, transparent 100%),
                linear-gradient(135deg, rgba(212, 175, 122, 0.06) 0%, rgba(18, 16, 14, 0.85) 50%, rgba(212, 175, 122, 0.03) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-sm), inset 1px 0 0 rgba(255, 255, 255, 0.03);
        }
        
        .sidebar-header { padding: 16px 20px; border-bottom: 1px solid var(--glass-border); background: rgba(0, 0, 0, 0.2); }
        .sidebar-title { 
            font-size: 0.875em; 
            font-weight: 600; 
            text-transform: uppercase; 
            color: var(--text-muted); 
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: 0.05em;
        }
        
        .scene-count {
            background: var(--accent-gold);
            color: var(--bg-dark);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 700;
        }
        
        .scene-search {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
        }
        .scene-search:focus { outline: none; border-color: var(--accent-gold); }
        
        .scene-list { flex: 1; overflow-y: auto; padding: 12px; }
        
        /* Scene Card - Collapsed State */
        .scene-item {
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.04) 0%, rgba(28, 25, 22, 0.5) 50%, rgba(212, 175, 122, 0.02) 100%);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .scene-item.int-day { border-left: 3px solid var(--int-day-border); }
        .scene-item.ext-day { border-left: 3px solid var(--ext-day-border); }
        .scene-item.int-night { border-left: 3px solid var(--int-night-border); }
        .scene-item.ext-night { border-left: 3px solid var(--ext-night-border); }
        
        .scene-item:hover {
            border-color: var(--accent-gold);
            transform: translateX(4px);
            box-shadow: var(--shadow-sm), 0 0 20px rgba(212, 175, 122, 0.15);
        }
        
        .scene-item.active {
            border-color: var(--accent-gold);
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.15) 0%, rgba(35, 31, 27, 0.7) 50%, rgba(212, 175, 122, 0.1) 100%);
            box-shadow: var(--shadow-sm), 0 0 25px rgba(212, 175, 122, 0.2);
            padding: 14px;
        }
        
        .scene-header { display: flex; align-items: flex-start; gap: 12px; }
        
        .scene-number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--accent-gold), #b89651);
            color: #0a0908;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.875em;
            flex-shrink: 0;
        }
        
        .scene-item.active .scene-number {
            width: 36px;
            height: 36px;
            font-size: 0.9375em;
        }
        
        .scene-info { flex: 1; min-width: 0; }
        .scene-heading { 
            font-size: 0.8125em; 
            font-weight: 600; 
            line-height: 1.4;
            margin-bottom: 4px;
            word-break: break-word;
        }
        
        .scene-meta {
            display: flex;
            gap: 6px;
            font-size: 0.6875em;
            color: var(--text-muted);
        }
        
        .scene-type-indicator {
            font-size: 0.625em;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .scene-type-indicator.int-day { background: var(--int-day); border: 1px solid var(--int-day-border); color: rgba(255, 255, 255, 0.9); }
        .scene-type-indicator.ext-day { background: var(--ext-day); border: 1px solid var(--ext-day-border); color: #0a0908; }
        .scene-type-indicator.int-night { background: var(--int-night); border: 1px solid var(--int-night-border); color: #0a0908; }
        .scene-type-indicator.ext-night { background: var(--ext-night); border: 1px solid var(--ext-night-border); color: #0a0908; }
        
        /* Expanded content */
        .scene-expanded {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(212, 175, 122, 0.2);
        }
        
        .scene-item.active .scene-expanded {
            display: block;
        }
        
        .scene-synopsis {
            font-size: 0.75em;
            color: var(--text-muted);
            line-height: 1.5;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .scene-synopsis.placeholder {
            opacity: 0.5;
        }
        
        .scene-cast-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }
        
        .cast-chip {
            padding: 3px 7px;
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            border-radius: 4px;
            font-size: 0.625em;
            font-weight: 600;
        }
        
        .element-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 0.6875em;
        }
        
        .element-count {
            padding: 2px 6px;
            background: rgba(102, 126, 234, 0.15);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 3px;
            color: #8b9cec;
        }
        
        /* Center Panel - Script */
        .center-panel { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(232, 230, 227, 0.02); }

        /* Center Panel Tabs */
        .center-tabs {
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            gap: 4px;
            row-gap: 6px;
            padding: 8px 12px;
            background:
                linear-gradient(to bottom, rgba(255, 255, 255, 0.03) 0%, transparent 100%),
                linear-gradient(135deg, rgba(212, 175, 122, 0.08) 0%, rgba(18, 16, 14, 0.85) 50%, rgba(212, 175, 122, 0.05) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            border-bottom: 1px solid var(--glass-border);
            overflow: visible;
        }

        .center-tab {
            padding: 6px 12px;
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: fit-content;
            max-width: 150px;
        }

        .center-tab[data-tab="script"] {
            padding: 6px 14px;
            font-size: 0.8125em;
            font-weight: 700;
            order: -1;
        }

        .center-tab > span:first-child {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .center-tab:hover {
            background: rgba(28, 25, 22, 0.5);
            color: var(--text-light);
        }

        .center-tab.active {
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.15), rgba(212, 175, 122, 0.08));
            border-bottom-color: transparent;
            color: var(--accent-gold);
            box-shadow: 0 -2px 8px rgba(212, 175, 122, 0.2);
        }

        .center-tab-close {
            margin-left: 2px;
            padding: 2px 3px;
            border-radius: 3px;
            opacity: 0.6;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .center-tab-close:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.1);
        }

        .center-tab-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .center-tab-panel {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
        }

        .center-tab-panel.active {
            display: flex;
        }

        /* Character Timeline View */
        .character-timeline-view {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .character-header {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--glass-border);
        }

        .character-name-title {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--accent-gold);
            margin-bottom: 8px;
        }

        .character-base-info {
            font-size: 0.875em;
            color: var(--text-muted);
            line-height: 1.6;
        }

        .character-stats {
            display: flex;
            gap: 20px;
            margin-top: 12px;
            font-size: 0.8125em;
        }

        .character-stat {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-muted);
        }

        .character-stat-value {
            color: var(--accent-gold);
            font-weight: 700;
        }

        /* Timeline Section */
        .timeline-section {
            margin-bottom: 32px;
        }

        .timeline-section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: rgba(212, 175, 122, 0.08);
            border-left: 3px solid var(--accent-gold);
            border-radius: 6px;
        }

        .timeline-section-title {
            font-size: 1em;
            font-weight: 600;
            color: var(--text-light);
        }

        .timeline-section-count {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .timeline-scene-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-left: 20px;
        }

        .timeline-scene-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-scene-item:hover {
            background: rgba(28, 25, 22, 0.5);
            border-color: var(--accent-gold);
            transform: translateX(4px);
        }

        .timeline-scene-number {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent-gold), #b89651);
            color: #0a0908;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.875em;
            flex-shrink: 0;
        }

        .timeline-scene-info {
            flex: 1;
            min-width: 0;
        }

        .timeline-scene-heading {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .timeline-scene-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .timeline-scene-badges {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .timeline-badge {
            padding: 2px 6px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            border-radius: 4px;
            font-size: 0.6875em;
            font-weight: 600;
            color: #8b9cec;
        }

        .timeline-badge.continuity {
            background: rgba(251, 191, 36, 0.2);
            border-color: rgba(251, 191, 36, 0.4);
            color: #fbbf24;
        }

        .timeline-continuity-events {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(212, 175, 122, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
        }

        .timeline-continuity-title {
            font-size: 0.9375em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-event-card {
            padding: 12px;
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-left: 3px solid var(--accent-gold);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.8125em;
        }

        .timeline-event-card:last-child {
            margin-bottom: 0;
        }

        .timeline-event-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .timeline-event-icon {
            font-size: 1.2em;
        }

        .timeline-event-description {
            font-weight: 600;
            color: var(--text-light);
        }

        .timeline-event-range {
            font-size: 0.9em;
            color: var(--text-muted);
        }

        /* Story Day Cards - Visual Timeline */
        .timeline-header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--glass-border);
        }

        .timeline-stats {
            display: flex;
            gap: 32px;
            margin-top: 16px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .stat-label {
            font-size: 0.75em;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px 0;
        }

        .nav-btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 0.8125em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.05);
        }

        .view-mode-switcher {
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 8px;
        }

        .mode-btn {
            padding: 6px 16px;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.8125em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mode-btn.active {
            background: var(--accent-gold);
            color: var(--bg-dark);
        }

        .story-day-timeline {
            display: flex;
            gap: 16px;
            overflow-x: auto;
            padding: 24px 0;
            scroll-snap-type: x mandatory;
        }

        .story-day-card {
            min-width: 320px;
            max-width: 320px;
            background: linear-gradient(135deg,
                rgba(212, 175, 122, 0.08) 0%,
                rgba(28, 25, 22, 0.6) 50%,
                rgba(212, 175, 122, 0.05) 100%
            );
            backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            scroll-snap-align: start;
            transition: all 0.3s ease;
        }

        .story-day-card:hover {
            border-color: var(--accent-gold);
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(212, 175, 122, 0.2);
        }

        .day-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .day-label {
            font-size: 0.9375em;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .scene-count {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .reference-image-zone {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed var(--glass-border);
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .reference-image-zone:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.08);
        }

        .image-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
        }

        .upload-icon {
            font-size: 2em;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 0.8125em;
            font-weight: 500;
        }

        .day-reference-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .reference-image-zone:hover .image-overlay {
            opacity: 1;
        }

        .change-image-btn {
            padding: 8px 16px;
            background: var(--accent-gold);
            color: var(--bg-dark);
            border: none;
            border-radius: 6px;
            font-size: 0.875em;
            font-weight: 600;
            cursor: pointer;
        }

        .look-summary {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .look-field {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            font-size: 0.8125em;
        }

        .look-field.has-event {
            background: rgba(212, 175, 122, 0.15);
            border-left: 3px solid var(--accent-gold);
        }

        .look-field.empty {
            opacity: 0.5;
        }

        .field-icon {
            font-size: 1.1em;
            line-height: 1;
        }

        .field-text {
            flex: 1;
            color: var(--text-light);
            line-height: 1.4;
        }

        .event-indicator {
            margin-left: 4px;
            color: var(--accent-gold);
            font-size: 0.9em;
        }

        .active-events-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(212, 175, 122, 0.2);
            border: 1px solid rgba(212, 175, 122, 0.4);
            border-radius: 6px;
            font-size: 0.75em;
            color: var(--accent-gold);
            margin-bottom: 12px;
        }

        .event-icon {
            font-size: 1.1em;
        }

        .expand-day-btn {
            width: 100%;
            padding: 8px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.8125em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .expand-day-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.05);
        }

        .expanded-scene-list {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--glass-border);
        }

        .scene-item {
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .scene-item:hover {
            background: rgba(212, 175, 122, 0.15);
            transform: translateX(4px);
        }

        .scene-number {
            font-size: 0.75em;
            font-weight: 700;
            color: var(--accent-gold);
            margin-bottom: 2px;
        }

        .scene-heading {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .scene-look-detail {
            font-size: 0.75em;
            color: var(--text-muted);
            line-height: 1.4;
        }

        .no-events-badge {
            font-size: 0.75em;
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: 12px;
        }

        .event-badge {
            padding: 6px 10px;
            background: rgba(212, 175, 122, 0.15);
            border: 1px solid rgba(212, 175, 122, 0.3);
            border-radius: 6px;
            font-size: 0.75em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .event-badge.fresh {
            border-left: 3px solid #ff6b6b;
        }

        .event-badge.healing {
            border-left: 3px solid #e8a87c;
        }

        .event-badge.healed {
            border-left: 3px solid #52c186;
        }

        .event-badge-icon {
            font-size: 1.1em;
        }

        .event-badge-text {
            flex: 1;
            color: var(--text-light);
        }

        .event-badge-stage {
            font-size: 0.85em;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .script-toolbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 12px 20px;
            background: var(--bg-medium);
            border-bottom: 1px solid var(--glass-border);
        }
        
        .view-controls { display: flex; gap: 8px; }
        .view-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .view-btn:hover { border-color: var(--accent-gold); color: var(--accent-gold); background: rgba(201, 169, 97, 0.05); }
        
        .script-viewer { flex: 1; overflow-y: auto; padding: 60px 40px; }
        .script-container {
            max-width: 700px;
            margin: 0 auto;
            background: rgba(248, 246, 240, 0.95);
            padding: 60px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        }
        
        .script-content { 
            font-family: 'Courier Prime', 'Courier New', monospace; 
            font-size: 13pt; 
            line-height: 1.8; 
            color: #1a1a1a; 
        }
        
        .script-scene { position: relative; padding-bottom: 20px; margin-bottom: 20px; }
        .script-scene::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: -40px;
            right: -40px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 122, 0.2) 20%, rgba(212, 175, 122, 0.2) 80%, transparent);
        }
        .script-scene:last-child::after { display: none; }
        
        .scene-header-wrapper { position: relative; margin-bottom: 20px; padding: 12px 0; border-radius: 4px; transition: all 0.2s ease; }
        .scene-header-wrapper:hover { background: rgba(212, 175, 122, 0.05); }
        
        .script-scene-heading { 
            font-weight: 700; 
            text-transform: uppercase; 
            color: #000;
            font-size: 13pt;
            letter-spacing: 0.5px;
            display: inline-block;
        }
        
        .scene-number-badge {
            display: inline-block;
            font-size: 0.65em;
            color: var(--accent-gold);
            font-weight: 600;
            margin-right: 12px;
            padding: 2px 8px;
            background: rgba(212, 175, 122, 0.1);
            border-radius: 4px;
            vertical-align: middle;
        }
        
        .script-action { margin-bottom: 16px; color: #1a1a1a; }
        .script-character { margin: 24px 0 0; text-align: center; text-transform: uppercase; color: #000; font-weight: 600; letter-spacing: 1px; }
        .script-dialogue { margin: 4px 0 16px; width: 65%; margin-left: 17.5%; color: #1a1a1a; }
        .script-parenthetical { margin: 0 0 4px; width: 55%; margin-left: 22.5%; color: #333; font-style: italic; }
        .script-transition { text-align: right; margin: 24px 0; font-weight: 600; color: #000; text-transform: uppercase; }

        /* Tag Highlighting System */
        .tag-highlight {
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 2px;
            padding: 1px 2px;
        }

        /* Cast Member Highlighting - Normalized */
        .tag-highlight[data-category="cast"] {
            background: rgba(251, 191, 36, 0.2);
        }

        /* Special styling for character introductions */
        .tag-highlight[data-category="cast"][data-introduction="true"] {
            background: rgba(251, 191, 36, 0.25);
            border: 1px solid rgba(251, 191, 36, 0.4);
            padding: 2px 4px;
            border-radius: 2px;
            box-shadow: 0 0 4px rgba(251, 191, 36, 0.2);
        }

        /* Other categories */
        .tag-highlight[data-category="hair"] { background: rgba(168, 85, 247, 0.2); }
        .tag-highlight[data-category="makeup"] { background: rgba(236, 72, 153, 0.2); }
        .tag-highlight[data-category="sfx"] { background: rgba(239, 68, 68, 0.2); }
        .tag-highlight[data-category="health"] { background: rgba(245, 158, 11, 0.2); }
        .tag-highlight[data-category="injuries"] { background: rgba(220, 38, 38, 0.2); }
        .tag-highlight[data-category="stunts"] { background: rgba(249, 115, 22, 0.2); }
        .tag-highlight[data-category="weather"] { background: rgba(56, 189, 248, 0.2); }
        .tag-highlight[data-category="wardrobe"] { background: rgba(52, 211, 153, 0.2); }
        .tag-highlight[data-category="extras"] { background: rgba(156, 163, 175, 0.2); }

        .tag-highlight:hover {
            filter: brightness(1.2);
            box-shadow: 0 0 0 2px currentColor;
        }

        /* Tag Popup */
        .tag-popup {
            position: fixed;
            bottom: 80px;
            right: 40px;
            width: 380px;
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.08) 0%, rgba(18, 16, 14, 0.95) 50%, rgba(212, 175, 122, 0.05) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: none;
        }

        .tag-popup.active {
            display: block;
            animation: slideInUp 0.3s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tag-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--glass-border);
        }

        .tag-popup-title {
            font-size: 0.9375em;
            font-weight: 600;
            color: var(--accent-gold);
        }

        .tag-popup-close {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .tag-popup-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        .tag-popup-body {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .tag-field {
            margin-bottom: 16px;
        }

        .tag-field label {
            display: block;
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .tag-selected-text {
            padding: 8px 12px;
            background: rgba(212, 175, 122, 0.15);
            border: 1px solid var(--accent-gold);
            border-radius: 6px;
            font-size: 0.875em;
            color: var(--text-light);
            font-family: 'Courier Prime', monospace;
        }

        .tag-field select,
        .tag-field textarea {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
            font-family: 'Inter', sans-serif;
        }

        .tag-field select:focus,
        .tag-field textarea:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .tag-field textarea {
            resize: vertical;
            font-family: 'Courier Prime', monospace;
            line-height: 1.5;
        }

        .tag-radio-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tag-radio {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8125em;
            color: var(--text-light);
            cursor: pointer;
        }

        .tag-radio input[type="radio"] {
            cursor: pointer;
        }

        .tag-popup-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 16px 20px;
            border-top: 1px solid var(--glass-border);
        }

        /* Tag Tooltip */
        .tag-tooltip {
            position: fixed;
            max-width: 400px;
            background: linear-gradient(135deg,
                rgba(212, 175, 122, 0.15) 0%,
                rgba(18, 16, 14, 0.98) 50%,
                rgba(212, 175, 122, 0.1) 100%
            );
            backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--accent-gold);
            border-radius: 8px;
            padding: 16px;
            z-index: 3000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tooltip-header {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        .tooltip-category {
            padding: 3px 8px;
            background: rgba(212, 175, 122, 0.3);
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .tooltip-character {
            font-size: 0.8125em;
            color: var(--text-muted);
        }

        .tooltip-text {
            font-size: 0.9375em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 8px;
        }

        .tooltip-context {
            font-size: 0.8125em;
            color: var(--text-muted);
            line-height: 1.5;
            margin-bottom: 12px;
            font-family: 'Courier Prime', monospace;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .tooltip-actions {
            display: flex;
            gap: 6px;
            justify-content: flex-end;
        }

        .tooltip-actions button {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tooltip-actions button:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* Margin Indicators */
        .script-action,
        .script-dialogue,
        .script-character,
        .script-parenthetical {
            position: relative;
        }

        .margin-indicators {
            position: absolute;
            left: -35px;
            top: 2px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .margin-indicator {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625em;
            font-weight: 700;
            color: #0a0908;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .margin-indicator:hover {
            transform: scale(1.15);
        }

        .margin-indicator.continuity {
            position: relative;
        }

        .margin-indicator.continuity::after {
            content: 'âš¡';
            position: absolute;
            top: -6px;
            right: -6px;
            font-size: 0.7em;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
        }

        /* Tags Tab */
        .tags-header {
            margin-bottom: 20px;
        }

        .tags-title {
            font-size: 1em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 16px;
        }

        .tags-filters {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tags-filter {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
        }

        .tags-filter:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .tags-stats {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(212, 175, 122, 0.05);
            border-radius: 8px;
            font-size: 0.8125em;
        }

        .tag-stat {
            color: var(--text-muted);
        }

        .tag-stat strong {
            color: var(--accent-gold);
            font-weight: 700;
        }

        .tags-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .tags-category-group {
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            overflow: hidden;
        }

        .tags-category-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--glass-border);
        }

        .category-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875em;
        }

        .category-name {
            flex: 1;
            font-size: 0.875em;
            font-weight: 600;
            color: var(--text-light);
        }

        .category-count {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .tags-by-character {
            padding: 16px;
        }

        .character-tags-group {
            margin-bottom: 16px;
        }

        .character-tags-group:last-child {
            margin-bottom: 0;
        }

        .character-tags-name {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tag-card {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag-card:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.1);
            transform: translateX(2px);
        }

        .tag-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .tag-card-text {
            font-size: 0.875em;
            font-weight: 600;
            color: var(--text-light);
        }

        .tag-card-badges {
            display: flex;
            gap: 4px;
        }

        .tag-badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.6875em;
            font-weight: 600;
        }

        .tag-badge.scene {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            color: #8b9cec;
        }

        .tag-badge.continuity {
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
        }

        .tag-card-context {
            font-size: 0.75em;
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .tag-card-actions {
            display: flex;
            gap: 8px;
        }

        .tag-action-btn {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tag-action-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* Color Legend */
        .color-legend {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7em;
            color: var(--text-muted);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Context Menu */
        .tag-context-menu {
            position: fixed;
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.1) 0%, rgba(18, 16, 14, 0.98) 50%, rgba(212, 175, 122, 0.08) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            min-width: 180px;
            padding: 4px;
        }

        .context-menu-item {
            padding: 8px 12px;
            font-size: 0.8125em;
            color: var(--text-light);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: rgba(212, 175, 122, 0.15);
            color: var(--accent-gold);
        }

        /* Right Sidebar - Workspace with Tabs */
        .right-sidebar {
            width: 380px;
            background: 
                linear-gradient(to left, rgba(255, 255, 255, 0.02) 0%, transparent 100%),
                linear-gradient(135deg, rgba(212, 175, 122, 0.06) 0%, rgba(18, 16, 14, 0.85) 50%, rgba(212, 175, 122, 0.03) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            border-left: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-sm), inset -1px 0 0 rgba(255, 255, 255, 0.03);
        }
        
        /* Workspace Header (Replaces Tab System) */
        .workspace-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.2);
        }

        .workspace-title {
            font-size: 0.875em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }

        /* Legacy Tab System (kept for character tabs) */
        .workspace-tabs {
            display: flex;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.2);
        }

        .workspace-tab {
            flex: 1;
            padding: 14px 16px;
            text-align: center;
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .workspace-tab:hover {
            color: var(--text-light);
            background: rgba(212, 175, 122, 0.05);
        }

        .workspace-tab.active {
            color: var(--accent-gold);
            border-bottom-color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.08);
        }
        
        .workspace-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .tab-panel {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .tab-panel.active {
            display: flex;
            flex-direction: column;
        }
        
        /* Scene Breakdown Tab */
        .breakdown-header {
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--glass-border);
        }
        
        .breakdown-scene-title {
            font-size: 0.875em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 4px;
        }
        
        .breakdown-scene-heading {
            font-size: 0.75em;
            color: var(--text-muted);
        }
        
        .ai-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .ai-btn {
            padding: 10px 14px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid var(--accent-blue);
            border-radius: 8px;
            color: var(--accent-blue);
            font-size: 0.8125em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .ai-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
            transform: translateY(-1px);
        }
        
        .ai-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .ai-btn .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--accent-blue);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Scene Navigation Bar - Ultra Compact */
        .breakdown-scene-nav {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            margin-bottom: 8px;
            background: linear-gradient(135deg,
                rgba(212, 175, 122, 0.08) 0%,
                rgba(28, 25, 22, 0.6) 50%,
                rgba(212, 175, 122, 0.05) 100%
            );
            backdrop-filter: blur(16px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
        }

        .scene-nav-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.6875em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            height: 32px;
        }

        .scene-nav-btn:hover:not(.disabled) {
            background: rgba(212, 175, 122, 0.15);
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            transform: translateX(0);
        }

        .scene-nav-btn:hover:not(.disabled):first-child {
            transform: translateX(-2px);
        }

        .scene-nav-btn:hover:not(.disabled):last-child {
            transform: translateX(2px);
        }

        .scene-nav-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .nav-arrow {
            font-size: 1.1em;
            font-weight: 700;
        }

        .nav-text {
            font-size: 0.875em;
        }

        .scene-nav-current {
            flex: 1;
            text-align: center;
            padding: 2px 6px;
        }

        .nav-scene-number {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 1px;
        }

        .nav-scene-heading {
            font-size: 0.6875em;
            color: var(--text-light);
            margin-bottom: 1px;
            line-height: 1.1;
        }

        .nav-scene-meta {
            font-size: 0.625em;
            color: var(--text-muted);
            font-style: italic;
        }

        .nav-scene-meta span {
            margin: 0 4px;
        }

        /* Sticky Scene Navigation */
        .breakdown-scene-nav-sticky {
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 10px 14px;
            margin-bottom: 16px;
            background: linear-gradient(135deg,
                rgba(212, 175, 122, 0.12) 0%,
                rgba(28, 25, 22, 0.95) 50%,
                rgba(212, 175, 122, 0.08) 100%
            );
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .scene-nav-btn-compact {
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-width: 100px;
        }

        .scene-nav-btn-compact:hover:not(.disabled) {
            background: rgba(212, 175, 122, 0.15);
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .scene-nav-btn-compact.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .scene-nav-current-compact {
            flex: 1;
            text-align: center;
            font-size: 0.95em;
            font-weight: 700;
            color: var(--accent-gold);
            letter-spacing: 0.5px;
        }

        /* Scene Info Collapsible Section */
        .scene-info-section {
            margin-bottom: 16px;
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            overflow: hidden;
        }

        .scene-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .scene-info-header:hover {
            background: rgba(212, 175, 122, 0.08);
        }

        .scene-info-title {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
        }

        .scene-info-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 0.75em;
            cursor: pointer;
            padding: 0;
            transition: transform 0.2s ease;
        }

        .scene-info-content {
            display: none;
            padding: 0 14px 14px;
        }

        .scene-info-section.expanded .scene-info-content {
            display: block;
        }

        .scene-info-section.expanded .scene-info-toggle {
            transform: rotate(90deg);
        }

        /* Cast Member Preview (shown when collapsed) */
        .cast-member-preview {
            padding: 8px 14px;
            font-size: 0.75em;
            color: var(--text-muted);
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(212, 175, 122, 0.1);
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .cast-member-card.expanded .cast-member-preview {
            display: none;
        }

        /* Compact AI Controls */
        .ai-controls-compact {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
        }

        .ai-btn-compact {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.12), rgba(118, 75, 162, 0.12));
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            color: var(--accent-blue);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-btn-compact:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.2);
            transform: translateY(-1px);
        }

        .ai-btn-compact:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .ai-btn-compact .btn-icon {
            font-size: 1em;
        }

        .ai-btn-compact .btn-text {
            font-size: 0.95em;
        }

        .ai-btn-compact .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid var(--accent-blue);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .ai-controls-spacer {
            flex: 1;
        }

        .ai-status {
            font-size: 0.75em;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Visual Summary Dashboard */
        .breakdown-quick-summary {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
        }

        .quick-summary-title {
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }

        .quick-summary-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .summary-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .summary-badge:hover {
            background: rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }

        .summary-badge.empty {
            opacity: 0.4;
            cursor: default;
        }

        .summary-badge.empty:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: none;
        }

        .badge-icon {
            font-size: 1em;
        }

        .badge-label {
            flex: 1;
            font-size: 0.7em;
            font-weight: 500;
            color: var(--text-light);
        }

        .badge-count {
            font-size: 0.75em;
            font-weight: 700;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        /* Scene Detail Fields (for cast profile modal) */
        .scene-detail-section {
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 16px;
        }

        .detail-header {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--glass-border);
        }

        .detail-scene-info {
            font-size: 0.875em;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 4px;
        }

        .detail-story-day {
            font-size: 0.75em;
            color: var(--text-muted);
            font-style: italic;
        }

        .detail-field {
            margin-bottom: 16px;
        }

        .detail-field:last-child {
            margin-bottom: 0;
        }

        .detail-field-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .detail-label {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
        }

        .ai-generate-btn {
            padding: 4px 10px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid var(--accent-blue);
            border-radius: 4px;
            color: var(--accent-blue);
            font-size: 0.6875em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .ai-generate-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
        }

        .detail-tags {
            font-size: 0.75em;
            color: var(--text-muted);
            margin-bottom: 6px;
            font-style: italic;
        }

        .detail-tag {
            background: rgba(102, 126, 234, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            margin-right: 4px;
        }

        .detail-textarea {
            width: 100%;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
            font-family: 'Inter', sans-serif;
            resize: vertical;
            line-height: 1.4;
        }

        .detail-textarea:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        /* Scene Metadata Pills (Read-Only Overview in Left Sidebar) */
        .scene-metadata-overview {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
        }

        .metadata-pill {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: rgba(212, 175, 122, 0.15);
            border: 1px solid rgba(212, 175, 122, 0.3);
            border-radius: 12px;
            font-size: 0.6875em;
        }

        .metadata-pill-icon {
            font-size: 1em;
        }

        .metadata-pill-text {
            color: var(--accent-gold);
            font-weight: 600;
        }

        /* Breakdown Metadata Section (Editable Inputs in Right Panel) */
        .breakdown-metadata-section {
            background: rgba(212, 175, 122, 0.08);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .breakdown-metadata-field {
            margin-bottom: 12px;
        }

        .breakdown-metadata-field:last-child {
            margin-bottom: 0;
        }

        .breakdown-label {
            display: block;
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .breakdown-input,
        .breakdown-select {
            width: 100%;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
            font-family: 'Inter', sans-serif;
        }

        .breakdown-input:focus,
        .breakdown-select:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .breakdown-hint {
            font-size: 0.6875em;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 3px;
            opacity: 0.7;
        }

        /* Breakdown Synopsis Display */
        .breakdown-synopsis {
            background: rgba(212, 175, 122, 0.08);
            border-left: 3px solid var(--accent-gold);
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 6px;
            font-size: 0.8125em;
            line-height: 1.6;
            color: var(--text-light);
            font-style: italic;
        }

        /* Breakdown Cast Section */
        .breakdown-cast-section {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(251, 191, 36, 0.08);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: 8px;
        }

        .breakdown-section-label {
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 8px;
            letter-spacing: 0.05em;
        }

        .breakdown-cast-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .breakdown-cast-chip {
            padding: 4px 10px;
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
        }

        /* Breakdown Tags Summary */
        .breakdown-tags-summary {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(102, 126, 234, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
        }

        .breakdown-tags-counts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .breakdown-tag-count {
            padding: 4px 10px;
            background: rgba(102, 126, 234, 0.15);
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: #8b9cec;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
        }

        /* Compact Synopsis Section */
        .breakdown-synopsis-section {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(212, 175, 122, 0.08);
            border-left: 3px solid var(--accent-gold);
            border-radius: 6px;
        }

        .breakdown-synopsis-section .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }

        .synopsis-display {
            font-size: 0.8125em;
            line-height: 1.5;
            color: var(--text-light);
            font-style: italic;
        }

        /* Scene Info Compact 3-Column Layout */
        .scene-info-compact {
            background: rgba(212, 175, 122, 0.08);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .info-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .info-field.full-width {
            grid-column: 1 / -1;
        }

        .info-field label {
            font-size: 0.6875em;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-field input,
        .info-field select {
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-light);
            font-size: 0.8125em;
            font-family: inherit;
        }

        .info-field input:focus,
        .info-field select:focus {
            outline: none;
            border-color: var(--accent-gold);
            background: rgba(0, 0, 0, 0.4);
        }

        .ai-detect-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--glass-border);
        }

        /* Tagged Pills (compact, only non-empty) */
        .tagged-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 16px;
        }

        .tagged-pill {
            padding: 4px 10px;
            background: rgba(102, 126, 234, 0.15);
            border: 1px solid rgba(102, 126, 234, 0.3);
            color: #8b9cec;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tagged-pill:hover {
            background: rgba(102, 126, 234, 0.25);
            border-color: var(--accent-blue);
        }

        /* Mini AI Button in Cast Header */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-mini-btn {
            padding: 4px 8px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            color: var(--accent-blue);
            font-size: 0.6875em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .ai-mini-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
            border-color: var(--accent-blue);
        }

        /* Cast Profile Modal Redesign */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid var(--glass-border);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        .profile-base-section {
            padding: 20px 24px;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(212, 175, 122, 0.05);
        }

        .profile-scenes-count {
            margin-top: 12px;
            font-size: 0.8125em;
            color: var(--text-muted);
        }

        .scenes-list {
            color: var(--accent-gold);
            font-weight: 600;
        }

        .profile-continuity-section {
            padding: 20px 24px;
            border-bottom: 1px solid var(--glass-border);
            max-height: 400px;
            overflow-y: auto;
        }

        .profile-scenes-section {
            padding: 20px 24px;
        }

        .profile-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .profile-section-title {
            font-size: 0.9375em;
            font-weight: 600;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .profile-add-btn,
        .profile-filter-btn {
            padding: 6px 12px;
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.15), rgba(212, 175, 122, 0.1));
            border: 1px solid var(--accent-gold);
            border-radius: 6px;
            color: var(--accent-gold);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .profile-add-btn:hover,
        .profile-filter-btn:hover {
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.25), rgba(212, 175, 122, 0.15));
            transform: translateY(-1px);
        }

        .profile-filter-btn.active {
            background: var(--accent-gold);
            color: var(--bg-dark);
        }

        /* Continuity Event Card */
        .continuity-event-card {
            background: rgba(28, 25, 22, 0.5);
            border: 1px solid var(--glass-border);
            border-left: 3px solid var(--accent-gold);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .continuity-event-card:hover {
            border-left-width: 4px;
            background: rgba(28, 25, 22, 0.7);
        }

        .event-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .event-card-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9375em;
            font-weight: 600;
            color: var(--text-light);
        }

        .event-card-icon {
            font-size: 1.25em;
        }

        .event-card-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .event-card-progression {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .event-card-progression-title {
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 0.05em;
        }

        .event-progression-stage {
            padding: 6px 0;
            font-size: 0.8125em;
            color: var(--text-light);
            line-height: 1.5;
        }

        .event-card-actions {
            display: flex;
            gap: 8px;
        }

        .event-action-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .event-action-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .event-action-btn.danger:hover {
            border-color: var(--error);
            color: var(--error);
        }

        /* Scene Quick View */
        .scene-quick-item {
            background: rgba(28, 25, 22, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .scene-quick-item:hover {
            background: rgba(28, 25, 22, 0.5);
            border-color: rgba(212, 175, 122, 0.3);
        }

        .scene-quick-item.has-events {
            border-left: 3px solid var(--accent-gold);
        }

        .scene-quick-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .scene-quick-title {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
        }

        .scene-quick-events {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.75em;
            color: var(--accent-gold);
        }

        .scene-quick-details {
            font-size: 0.75em;
            color: var(--text-muted);
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .scene-quick-actions {
            display: flex;
            gap: 8px;
        }

        .scene-quick-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.6875em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .scene-quick-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .empty-state-small {
            text-align: center;
            padding: 40px 20px;
        }

        .empty-icon-small {
            font-size: 2.5em;
            margin-bottom: 12px;
            opacity: 0.3;
        }

        .empty-text-small {
            font-size: 0.8125em;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .profile-section {
            margin-bottom: 16px;
        }

        .profile-label {
            display: block;
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .modal-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
        }

        .modal-select:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .modal-textarea {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
            font-family: 'Inter', sans-serif;
            resize: vertical;
            line-height: 1.5;
        }

        .modal-textarea:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .breakdown-section {
            margin-bottom: 8px;
            background: rgba(28, 25, 22, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .breakdown-section.expanded {
            margin-bottom: 12px;
        }

        .breakdown-section.has-content {
            border-color: rgba(212, 175, 122, 0.2);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(0, 0, 0, 0.2);
        }

        .section-header:hover {
            background: rgba(212, 175, 122, 0.08);
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .section-title {
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-light);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-icon {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .category-count {
            font-size: 0.7em;
            font-weight: 700;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: var(--text-muted);
        }

        .category-count.has-items {
            background: rgba(212, 175, 122, 0.3);
            color: var(--accent-gold);
        }

        .category-toggle {
            padding: 4px 8px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .section-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 12px;
        }

        .breakdown-section.expanded .section-content {
            max-height: 2000px;
            padding: 0 12px 12px 12px;
        }
        
        .add-element-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px dashed var(--glass-border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.625em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }
        
        .add-element-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(201, 169, 97, 0.05);
        }
        
        .element-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .element-item {
            padding: 10px 12px;
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            font-size: 0.8125em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .element-item:hover {
            border-color: var(--accent-gold);
            background: rgba(201, 169, 97, 0.05);
        }
        
        .element-text { flex: 1; }
        
        .element-remove {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.125em;
            padding: 0 4px;
            transition: all 0.2s ease;
        }
        
        .element-remove:hover {
            color: var(--error);
        }
        
        /* Cast in Scene Tab */
        .cast-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .cast-card {
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 14px;
            transition: all 0.2s ease;
        }
        
        .cast-card:hover {
            border-color: rgba(251, 191, 36, 0.5);
            background: rgba(251, 191, 36, 0.05);
        }
        
        .cast-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .cast-name {
            font-size: 0.9375em;
            font-weight: 600;
            color: #fbbf24;
        }
        
        .profile-btn {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.625em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
        }
        
        .profile-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }
        
        .cast-base-desc {
            font-size: 0.75em;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-style: italic;
            line-height: 1.4;
        }
        
        /* Active Continuity States */
        .active-states {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
        }
        
        .active-states-title {
            font-size: 0.6875em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 8px;
            letter-spacing: 0.05em;
        }
        
        .continuity-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 0.75em;
            transition: all 0.2s ease;
        }
        
        .continuity-item:last-child {
            margin-bottom: 0;
        }
        
        .continuity-item:hover {
            border-color: var(--accent-gold);
            background: rgba(201, 169, 97, 0.05);
        }
        
        .continuity-icon {
            font-size: 1.2em;
            flex-shrink: 0;
        }
        
        .continuity-content {
            flex: 1;
            min-width: 0;
        }
        
        .continuity-desc {
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 2px;
        }
        
        .continuity-stage {
            color: var(--text-muted);
            font-size: 0.9em;
            font-style: italic;
        }
        
        .continuity-timeline {
            font-size: 0.85em;
            color: var(--accent-blue);
            margin-top: 3px;
        }
        
        .continuity-actions {
            display: flex;
            gap: 4px;
        }
        
        .continuity-edit-btn {
            padding: 2px 6px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 3px;
            color: var(--text-muted);
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .continuity-edit-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }
        
        .add-continuity-btn {
            width: 100%;
            padding: 8px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px dashed var(--accent-blue);
            border-radius: 6px;
            color: var(--accent-blue);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            text-align: center;
            margin-bottom: 12px;
        }
        
        .add-continuity-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
            border-color: var(--accent-blue);
            border-style: solid;
        }

        /* Continuity Progress Bar */
        .continuity-progress {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg,
                #ef4444 0%,
                #f59e0b 50%,
                #10b981 100%
            );
            transition: width 0.3s ease;
        }

        .progress-label {
            font-size: 0.75em;
            color: var(--text-muted);
            min-width: 80px;
            text-align: right;
        }

        /* Event Badge Styling */
        .event-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: 600;
        }

        .event-badge.fresh {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        .event-badge.healing {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.4);
        }

        .event-badge.healed {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.4);
        }

        /* Story Day Card Styling */
        .story-day-cards-container {
            display: flex;
            gap: 16px;
            overflow-x: auto;
            padding: 16px;
            margin-bottom: 24px;
        }

        .story-day-card {
            min-width: 280px;
            max-width: 280px;
            background: linear-gradient(135deg,
                rgba(212, 175, 122, 0.08) 0%,
                rgba(28, 25, 22, 0.5) 50%,
                rgba(212, 175, 122, 0.05) 100%
            );
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            transition: all 0.3s ease;
        }

        .story-day-card:hover {
            border-color: var(--accent-gold);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(212, 175, 122, 0.15);
        }

        .day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .day-label {
            font-size: 0.875em;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .scene-count {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .reference-image {
            width: 100%;
            height: 180px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .reference-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-btn {
            position: absolute;
            background: rgba(201, 169, 97, 0.9);
            color: var(--bg-dark);
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875em;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .upload-btn:hover {
            background: var(--accent-gold);
            transform: scale(1.05);
        }

        .look-details {
            margin-bottom: 12px;
        }

        .detail-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 0.75em;
        }

        .detail-row:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            font-weight: 700;
            color: var(--text-muted);
            min-width: 70px;
        }

        .detail-value {
            color: var(--text-light);
            flex: 1;
        }

        .active-events {
            margin-bottom: 12px;
        }

        .expand-btn {
            width: 100%;
            padding: 8px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .expand-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.05);
        }

        .expanded-scenes {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--glass-border);
        }

        .scene-detail {
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 0.75em;
        }

        .scene-detail strong {
            color: var(--accent-gold);
        }

        .scene-look {
            margin-top: 4px;
            color: var(--text-muted);
            font-size: 0.95em;
        }

        /* Cast Member Expandable Card in Scene Breakdown */
        .cast-member-card {
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-left: 3px solid rgba(251, 191, 36, 0.4);
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .cast-member-card:hover {
            border-left-color: #fbbf24;
            background: rgba(28, 25, 22, 0.6);
        }

        .cast-member-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 14px;
            cursor: pointer;
        }

        .cast-member-name {
            font-size: 0.9375em;
            font-weight: 600;
            color: #fbbf24;
        }

        .cast-member-toggle {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .cast-member-body {
            padding: 0 14px 14px;
            display: none;
        }

        .cast-member-card.expanded .cast-member-body {
            display: block;
        }

        .cast-member-card.expanded .cast-member-toggle::before {
            content: 'â–¼ ';
        }

        .cast-member-toggle::before {
            content: 'â–¶ ';
        }

        .cast-member-base {
            font-size: 0.75em;
            color: var(--text-muted);
            margin-bottom: 12px;
            font-style: italic;
        }

        .active-events-section {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
        }

        .active-events-title {
            font-size: 0.6875em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 8px;
            letter-spacing: 0.05em;
        }

        .event-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .event-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .event-name {
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 4px;
        }

        .event-timeline-info {
            font-size: 0.6875em;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .department-fields {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .department-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .department-label {
            font-size: 0.6875em;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .department-input {
            width: 100%;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.8125em;
            font-family: 'Inter', sans-serif;
        }

        .department-input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .cast-member-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .view-timeline-btn {
            flex: 1;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.15), rgba(212, 175, 122, 0.1));
            border: 1px solid var(--accent-gold);
            border-radius: 6px;
            color: var(--accent-gold);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .view-timeline-btn:hover {
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.25), rgba(212, 175, 122, 0.15));
            transform: translateY(-1px);
        }

        .ai-fill-btn {
            flex: 1;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid var(--accent-blue);
            border-radius: 6px;
            color: var(--accent-blue);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .ai-fill-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
        }

        /* Timeline View Modes */
        .timeline-view-modes {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            padding: 12px;
            background: rgba(212, 175, 122, 0.05);
            border-radius: 8px;
        }

        .view-mode-btn {
            flex: 1;
            padding: 8px 12px;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.75em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .view-mode-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .view-mode-btn.active {
            background: var(--accent-gold);
            color: var(--bg-dark);
            border-color: var(--accent-gold);
        }

        /* Reference Images Section */
        .reference-images-section {
            padding: 20px 24px;
            border-top: 1px solid var(--glass-border);
        }

        .reference-images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }

        .reference-image-item {
            position: relative;
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reference-image-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(212, 175, 122, 0.3);
        }

        .reference-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .reference-image-item.upload-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--glass-border);
            background: rgba(0, 0, 0, 0.2);
        }

        .reference-image-item.upload-placeholder:hover {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 122, 0.05);
        }

        .print-lookbook-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.2), rgba(212, 175, 122, 0.1));
            border: 1px solid var(--accent-gold);
            border-radius: 8px;
            color: var(--accent-gold);
            font-size: 0.875em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .print-lookbook-btn:hover {
            background: linear-gradient(135deg, rgba(212, 175, 122, 0.3), rgba(212, 175, 122, 0.2));
            transform: translateY(-1px);
        }
        
        .cast-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }
        
        .character-tag {
            padding: 3px 7px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            color: #8b9cec;
            border-radius: 4px;
            font-size: 0.6875em;
            font-weight: 500;
        }
        
        .character-tag.wound {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
            color: #f87171;
        }
        
        .add-tag-btn {
            padding: 3px 7px;
            background: transparent;
            border: 1px dashed rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            color: var(--accent-blue);
            font-size: 0.6875em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .add-tag-btn:hover {
            border-color: var(--accent-blue);
            background: rgba(102, 126, 234, 0.1);
        }
        
        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
            flex: 1;
        }
        
        .empty-icon { font-size: 2em; margin-bottom: 12px; opacity: 0.3; }
        .empty-title { font-size: 0.9375em; font-weight: 600; margin-bottom: 6px; }
        .empty-desc { font-size: 0.8125em; line-height: 1.5; }
        
        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            z-index: 2500;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--glass-bg);
            backdrop-filter: blur(30px);
            border: 1px solid var(--accent-gold);
            border-radius: 16px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(212, 175, 122, 0.2);
        }
        
        .modal-title {
            font-size: 1.125em;
            font-weight: 600;
            margin-bottom: 16px;
        }
        
        .modal-input {
            width: 100%;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.875em;
            margin-bottom: 16px;
        }
        
        .modal-input:focus { outline: none; border-color: var(--accent-gold); }
        
        .modal-textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.875em;
            margin-bottom: 16px;
            font-family: 'Inter', sans-serif;
            resize: vertical;
        }
        
        .modal-textarea:focus { outline: none; border-color: var(--accent-gold); }
        
        .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .modal-btn {
            padding: 8px 16px;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            background: transparent;
            color: var(--text-light);
            font-size: 0.875em;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .modal-btn.primary {
            background: linear-gradient(135deg, rgba(201, 169, 97, 0.9), rgba(184, 150, 81, 0.9));
            border-color: var(--accent-gold);
            color: var(--bg-dark);
        }
        
        .modal-btn:hover { border-color: var(--accent-gold); color: var(--accent-gold); }
        .modal-btn.primary:hover {
            background: linear-gradient(135deg, #d4af7a, #c09861);
            transform: translateY(-1px);
        }
        
        /* Cast Profile Modal */
        .cast-profile-modal .modal-content {
            max-width: 600px;
        }
        
        .profile-section {
            margin-bottom: 16px;
        }
        
        .profile-label {
            display: block;
            font-size: 0.8125em;
            color: var(--text-muted);
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .appearance-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            min-height: 40px;
        }
        
        .appearance-chip {
            padding: 4px 8px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            border-radius: 4px;
            font-size: 0.75em;
            color: var(--accent-blue);
        }

        /* Manage Looks Modal */
        .looks-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .look-state-card {
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-left: 3px solid rgba(201, 169, 97, 0.5);
            border-radius: 8px;
            padding: 14px;
            transition: all 0.2s ease;
        }

        .look-state-card:hover {
            background: rgba(28, 25, 22, 0.6);
            border-left-color: var(--accent-gold);
        }

        .look-state-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .look-state-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .look-state-name {
            font-size: 0.95em;
            font-weight: 600;
            color: var(--text-light);
        }

        .complexity-indicator {
            font-size: 1.1em;
        }

        .look-state-actions {
            display: flex;
            gap: 6px;
        }

        .look-action-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .look-action-btn:hover {
            background: rgba(201, 169, 97, 0.2);
            border-color: var(--accent-gold);
        }

        .look-action-btn.delete:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        .look-state-details {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .look-detail-row {
            display: flex;
            gap: 8px;
            font-size: 0.8125em;
        }

        .look-detail-label {
            color: var(--text-muted);
            font-weight: 500;
            min-width: 100px;
        }

        .look-detail-value {
            color: var(--text-light);
        }

        /* Edit Look State Modal */
        .modal-section {
            margin-bottom: 20px;
        }

        .modal-label {
            display: block;
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 8px;
        }

        .modal-input {
            width: 100%;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.875em;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .modal-textarea {
            width: 100%;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.875em;
            resize: vertical;
        }

        .modal-textarea:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .modal-select {
            width: 100%;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            color: var(--text-light);
            font-size: 0.875em;
            cursor: pointer;
        }

        .modal-select:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        /* Scene Checkboxes */
        .scene-checkboxes {
            max-height: 250px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .scene-checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .scene-checkbox-item:hover {
            background: rgba(28, 25, 22, 0.6);
            border-color: var(--accent-gold);
        }

        .scene-checkbox {
            cursor: pointer;
            width: 16px;
            height: 16px;
        }

        .scene-checkbox-label {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .scene-number {
            font-size: 0.75em;
            font-weight: 600;
            color: var(--accent-gold);
        }

        .scene-heading {
            font-size: 0.75em;
            color: var(--text-muted);
        }

        .selected-count {
            font-size: 0.75em;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Appearance Fields */
        .appearance-field {
            margin-bottom: 14px;
        }

        .field-sublabel {
            display: block;
            font-size: 0.75em;
            font-weight: 500;
            color: var(--text-light);
            margin-bottom: 6px;
        }

        /* Script Evidence */
        .evidence-subsection {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
        }

        .subsection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .subsection-label {
            font-size: 0.8125em;
            font-weight: 600;
            color: var(--text-light);
        }

        .add-item-btn {
            padding: 4px 10px;
            background: rgba(201, 169, 97, 0.15);
            border: 1px solid rgba(201, 169, 97, 0.3);
            border-radius: 4px;
            color: var(--accent-gold);
            font-size: 0.75em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-item-btn:hover {
            background: rgba(201, 169, 97, 0.25);
            border-color: var(--accent-gold);
        }

        .evidence-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .empty-evidence {
            padding: 10px;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.75em;
            font-style: italic;
        }

        .evidence-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(28, 25, 22, 0.5);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
        }

        .evidence-text {
            flex: 1;
            font-size: 0.8125em;
            color: var(--text-light);
            line-height: 1.4;
        }

        .evidence-remove-btn {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 4px;
            color: #ef4444;
            font-size: 1em;
            font-weight: 700;
            width: 24px;
            height: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .evidence-remove-btn:hover {
            background: rgba(239, 68, 68, 0.35);
            border-color: #ef4444;
        }

        /* Import Modal */
        .import-modal .modal-content {
            max-width: 900px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
        }
        
        .import-body {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .script-input {
            width: 100%;
            min-height: 400px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Courier New', monospace;
            font-size: 0.875em;
            line-height: 1.6;
            resize: vertical;
        }
        
        .script-input:focus { outline: none; border-color: var(--accent-gold); }
        
        .import-status {
            margin-top: 12px;
            padding: 10px 12px;
            background: rgba(82, 193, 134, 0.15);
            border: 1px solid rgba(82, 193, 134, 0.3);
            border-radius: 6px;
            font-size: 0.8125em;
            color: var(--success);
        }
        
        /* Continuity Event Modal */
        .continuity-modal .modal-content {
            max-width: 650px;
        }
        
        .modal-section {
            margin-bottom: 16px;
        }
        
        .modal-label {
            display: block;
            font-size: 0.8125em;
            color: var(--text-muted);
            margin-bottom: 6px;
            font-weight: 500;
        }
        
        .modal-select {
            width: 100%;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--text-light);
            font-size: 0.875em;
        }
        
        .modal-select:focus { outline: none; border-color: var(--accent-gold); }
        
        .scene-range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        
        .timeline-input-group {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 8px;
        }
        
        .ai-suggest-btn {
            padding: 10px 14px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid var(--accent-blue);
            border-radius: 8px;
            color: var(--accent-blue);
            font-size: 0.8125em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .ai-suggest-btn:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.3);
        }
        
        .ai-suggest-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .progression-list {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
        }
        
        .progression-stage {
            padding: 8px;
            background: rgba(28, 25, 22, 0.4);
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 0.8125em;
        }
        
        .progression-stage:last-child {
            margin-bottom: 0;
        }
        
        .progression-stage-label {
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 3px;
        }
        
        .progression-stage-note {
            color: var(--text-muted);
            font-size: 0.95em;
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="nav-section">
                <a href="#" class="back-link">â† Dashboard</a>
                <h1 class="page-title" id="projectTitle">Script Breakdown</h1>
            </div>
            <div class="toolbar">
                <button class="toolbar-btn" onclick="openMergeCharactersModal()">ðŸ”— Merge Characters</button>
                <button class="toolbar-btn" onclick="openSettingsModal()">âš™ï¸ AI Settings</button>
                <button class="toolbar-btn" onclick="exportData()">Export Data</button>
                <button class="toolbar-btn" onclick="openImportModal()">Import Script</button>
                <div id="autoSaveIndicator" class="auto-save-indicator" style="display: none;">
                    <span class="save-icon">âœ“</span>
                    <span class="save-text">Saved</span>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Sidebar - Scenes -->
            <div class="left-sidebar">
                <div class="sidebar-header">
                    <div class="sidebar-title">
                        <span>SCENES</span>
                        <span class="scene-count" id="sceneCount">0</span>
                    </div>
                    <input type="text" class="scene-search" placeholder="Search scenes..." id="sceneSearch">
                </div>
                <div class="scene-list" id="sceneList">
                    <div class="empty-state">
                        <div class="empty-icon">ðŸŽ¬</div>
                        <div class="empty-desc">No scenes yet</div>
                    </div>
                </div>
            </div>
            
            <!-- Center Panel - Script -->
            <div class="center-panel">
                <!-- NEW: Tab Bar -->
                <div class="center-tabs">
                    <div class="center-tab active" data-tab="script" onclick="switchCenterTab('script')">
                        ðŸ“„ Script
                    </div>
                    <!-- Character tabs generated dynamically here -->
                </div>

                <!-- Tab Content Container -->
                <div class="center-tab-content">
                    <!-- Script Tab (existing content) -->
                    <div class="center-tab-panel active" id="scriptTabPanel">
                        <div class="script-toolbar">
                            <div class="color-legend">
                                <span class="legend-item"><span class="legend-color" style="background: #fbbf24;"></span>Cast</span>
                                <span class="legend-item"><span class="legend-color" style="background: #a855f7;"></span>Hair</span>
                                <span class="legend-item"><span class="legend-color" style="background: #ec4899;"></span>Makeup</span>
                                <span class="legend-item"><span class="legend-color" style="background: #ef4444;"></span>SFX</span>
                                <span class="legend-item"><span class="legend-color" style="background: #f59e0b;"></span>Health</span>
                                <span class="legend-item"><span class="legend-color" style="background: #dc2626;"></span>Injuries</span>
                                <span class="legend-item"><span class="legend-color" style="background: #f97316;"></span>Stunts</span>
                                <span class="legend-item"><span class="legend-color" style="background: #38bdf8;"></span>Weather</span>
                                <span class="legend-item"><span class="legend-color" style="background: #34d399;"></span>Wardrobe</span>
                                <span class="legend-item"><span class="legend-color" style="background: #9ca3af;"></span>Extras</span>
                            </div>
                            <div class="view-controls">
                                <button class="view-btn" onclick="zoomIn()">Zoom In</button>
                                <button class="view-btn" onclick="zoomOut()">Zoom Out</button>
                            </div>
                        </div>

                        <div class="script-viewer" id="scriptViewer">
                            <div class="script-container">
                                <div class="script-content" id="scriptContent">
                                    <div class="empty-state">
                                        <div class="empty-icon">ðŸ“„</div>
                                        <div class="empty-title">No Script Loaded</div>
                                        <div class="empty-desc">Import your screenplay to begin</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Character Tab Panels (generated dynamically) -->
                </div>
            </div>
            
            <!-- Right Sidebar - Workspace -->
            <div class="right-sidebar">
                <div class="workspace-header">
                    <div class="workspace-title">SCENE BREAKDOWN</div>
                </div>

                <div class="workspace-content">
                    <!-- Scene Breakdown Tab (Only Tab) -->
                    <div class="tab-panel active" id="breakdownPanel">
                        <div class="empty-state">
                            <div class="empty-icon">ðŸ“‹</div>
                            <div class="empty-title">Select a Scene</div>
                            <div class="empty-desc">Choose a scene to view and edit its breakdown</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add Element Modal -->
    <div class="modal" id="addElementModal">
        <div class="modal-content">
            <div class="modal-title">Add Element</div>
            <input type="text" class="modal-input" id="elementInput" placeholder="Enter element name...">
            <div class="modal-actions">
                <button class="modal-btn" onclick="closeAddElementModal()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmAddElement()">Add</button>
            </div>
        </div>
    </div>
    
    <!-- Add Tag Modal -->
    <div class="modal" id="addTagModal">
        <div class="modal-content">
            <div class="modal-title" id="addTagTitle">Add Character Tag</div>
            <input type="text" class="modal-input" id="tagInput" placeholder="e.g., bruised face, torn shirt, dirty...">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; font-size: 0.875em;">
                <input type="checkbox" id="tagIsWound">
                <span>This is a wound/injury</span>
            </label>
            <div class="modal-actions">
                <button class="modal-btn" onclick="closeAddTagModal()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmAddTag()">Add Tag</button>
            </div>
        </div>
    </div>
    
    <!-- Cast Profile Modal - Enhanced Visual Timeline & Lookbook -->
    <div class="modal" id="castProfileModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <div class="modal-title" id="castProfileTitle">Cast Profile</div>
                <button class="modal-close" onclick="closeCastProfile()">Ã—</button>
            </div>

            <!-- Character-wide Base Info -->
            <div class="profile-base-section">
                <label class="profile-label">Base Description (Character-wide)</label>
                <textarea class="modal-textarea" id="castBaseDesc" rows="2" placeholder="Age, physical appearance, general characteristics..."></textarea>

                <div class="profile-scenes-count" id="scenesCount">
                    Appears in: <span class="scenes-list"></span>
                </div>
            </div>

            <div style="flex: 1; overflow-y: auto;">
                <!-- Visual Timeline Section -->
                <div style="padding: 20px 24px; border-bottom: 1px solid var(--glass-border);">
                    <div class="profile-section-header">
                        <span class="profile-section-title">ðŸ“¸ Visual Timeline</span>
                    </div>

                    <div class="story-day-cards-container" id="storyDayCardsContainer">
                        <!-- Story day cards populated dynamically -->
                    </div>

                    <div style="display: flex; justify-content: center; gap: 12px; margin-top: 12px;">
                        <button class="modal-btn" onclick="navigatePreviousDay()">â† Previous Day</button>
                        <button class="modal-btn" onclick="navigateNextDay()">Next Day â†’</button>
                    </div>
                </div>

                <!-- Continuity Events Section -->
                <div class="profile-continuity-section">
                    <div class="profile-section-header">
                        <span class="profile-section-title">âš¡ Continuity Events</span>
                        <button class="profile-add-btn" onclick="addContinuityEvent()">+ Add Event</button>
                    </div>

                    <div class="continuity-events-container" id="continuityEventsContainer">
                        <div class="empty-state-small">
                            <div class="empty-icon-small">âš¡</div>
                            <div class="empty-text-small">No continuity events yet. Click "+ Add Event" to create one.</div>
                        </div>
                    </div>
                </div>

                <!-- Reference Images Section -->
                <div class="reference-images-section">
                    <div class="profile-section-header">
                        <span class="profile-section-title">ðŸ“¸ Reference Images</span>
                    </div>

                    <div class="reference-images-grid" id="referenceImagesGrid">
                        <div class="reference-image-item upload-placeholder" onclick="uploadReferenceImage()">
                            + Upload
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal-actions">
                <button class="print-lookbook-btn" onclick="printLookbook()">ðŸ“„ Print Lookbook</button>
                <button class="modal-btn" onclick="openManageLooks(currentCastMember)">ðŸ“Š Manage Look States</button>
                <button class="modal-btn" onclick="closeCastProfile()">Close</button>
                <button class="modal-btn primary" onclick="saveCastProfile()">ðŸ’¾ Save All</button>
            </div>
        </div>
    </div>

    <!-- Manage Looks Modal -->
    <div class="modal" id="manageLooksModal">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h3 id="manageLooksTitle">Look States - [Character Name]</h3>
                <button class="modal-close" onclick="closeManageLooks()">Ã—</button>
            </div>

            <div style="flex: 1; overflow-y: auto; padding: 20px;">
                <div class="looks-list" id="looksList">
                    <!-- Look states will be populated here -->
                    <div class="empty-state-small">
                        <div class="empty-icon-small">ðŸ‘”</div>
                        <div class="empty-text-small">No look states defined yet. Click "+ Add Look State" to create one.</div>
                    </div>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn primary" onclick="addNewLook()">+ Add Look State</button>
                <button class="modal-btn" onclick="closeManageLooks()">Close</button>
            </div>
        </div>
    </div>

    <!-- Edit Look State Modal -->
    <div class="modal" id="editLookModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h3 id="editLookTitle">Edit Look State</h3>
                <button class="modal-close" onclick="closeEditLook()">Ã—</button>
            </div>

            <div style="flex: 1; overflow-y: auto; padding: 20px;">
                <!-- Look Name -->
                <div class="modal-section">
                    <label class="modal-label">Look Name</label>
                    <input type="text" class="modal-input" id="lookName" placeholder="e.g., Clean Professional, Post-Fight Injured, Casual Weekend">
                </div>

                <!-- Scene Selection -->
                <div class="modal-section">
                    <label class="modal-label">Scenes (select all that apply)</label>
                    <div class="scene-checkboxes" id="sceneCheckboxes">
                        <!-- Populated dynamically -->
                    </div>
                    <div class="selected-count" id="selectedScenesCount">0 scenes selected</div>
                </div>

                <!-- Story Time -->
                <div class="modal-section">
                    <label class="modal-label">Story Time / Timeline Context</label>
                    <input type="text" class="modal-input" id="lookStoryTime" placeholder="e.g., Day 1 - Morning to Afternoon, Week 2, 5 years later">
                </div>

                <!-- Appearance Fields -->
                <div class="modal-section">
                    <label class="modal-label">Appearance Details</label>

                    <div class="appearance-field">
                        <label class="field-sublabel">ðŸ’‡ Hair</label>
                        <textarea class="modal-textarea" id="lookHair" rows="2" placeholder="Hairstyle, color, condition, changes..."></textarea>
                    </div>

                    <div class="appearance-field">
                        <label class="field-sublabel">ðŸ’„ Makeup</label>
                        <textarea class="modal-textarea" id="lookMakeup" rows="2" placeholder="Makeup look, style, specific details..."></textarea>
                    </div>

                    <div class="appearance-field">
                        <label class="field-sublabel">ðŸ©¸ SFX Makeup</label>
                        <textarea class="modal-textarea" id="lookSfx" rows="2" placeholder="Injuries, wounds, bruises, prosthetics..."></textarea>
                    </div>

                    <div class="appearance-field">
                        <label class="field-sublabel">ðŸ‘” Wardrobe</label>
                        <textarea class="modal-textarea" id="lookWardrobe" rows="2" placeholder="Costume description, accessories, condition..."></textarea>
                    </div>

                    <div class="appearance-field">
                        <label class="field-sublabel">ðŸƒ Physical State</label>
                        <textarea class="modal-textarea" id="lookPhysicalState" rows="2" placeholder="Energy level, posture, movement, overall condition..."></textarea>
                    </div>
                </div>

                <!-- Script Evidence -->
                <div class="modal-section">
                    <label class="modal-label">Script Evidence</label>

                    <div class="evidence-subsection">
                        <div class="subsection-header">
                            <span class="subsection-label">Direct Quotes</span>
                            <button class="add-item-btn" onclick="addScriptQuote()">+ Add Quote</button>
                        </div>
                        <div class="evidence-list" id="scriptQuotesList">
                            <div class="empty-evidence">No quotes added yet</div>
                        </div>
                    </div>

                    <div class="evidence-subsection">
                        <div class="subsection-header">
                            <span class="subsection-label">Implications</span>
                            <button class="add-item-btn" onclick="addImplication()">+ Add Implication</button>
                        </div>
                        <div class="evidence-list" id="implicationsList">
                            <div class="empty-evidence">No implications added yet</div>
                        </div>
                    </div>
                </div>

                <!-- Complexity -->
                <div class="modal-section">
                    <label class="modal-label">Complexity Level</label>
                    <select class="modal-select" id="lookComplexity">
                        <option value="low">ðŸŸ¢ Low - Simple, easy to replicate</option>
                        <option value="medium">ðŸŸ¡ Medium - Moderate detail and effort</option>
                        <option value="high">ðŸ”´ High - Complex, requires significant time/skill</option>
                    </select>
                </div>

                <!-- Story Context -->
                <div class="modal-section">
                    <label class="modal-label">Story Context / Notes</label>
                    <textarea class="modal-textarea" id="lookStoryContext" rows="3" placeholder="Additional context about this look, why it matters, what happened before/after..."></textarea>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn" onclick="closeEditLook()">Cancel</button>
                <button class="modal-btn primary" onclick="saveLookState()">ðŸ’¾ Save Look State</button>
            </div>
        </div>
    </div>

    <!-- Import Script Modal -->
    <div class="modal import-modal" id="importModal">
        <div class="modal-content">
            <div class="modal-title">Import Screenplay</div>
            <div class="import-body">
                <textarea class="script-input" id="scriptInput" placeholder="Paste your screenplay here...

Example format:
INT. COFFEE SHOP - DAY

JANE (30s, professional, tired eyes) sits at a table, laptop open.

JANE
This is it. Today's the day."></textarea>
                <div class="import-status" id="importStatus" style="display: none;"></div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn" onclick="closeImportModal()">Cancel</button>
                <button class="modal-btn primary" onclick="processScript()" id="importBtn">Import & Analyze</button>
            </div>
        </div>
    </div>
    
    <!-- AI Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-title">AI Settings</div>
            
            <div class="modal-section">
                <label class="modal-label">AI Provider</label>
                <select class="modal-select" id="aiProvider">
                    <option value="openai">OpenAI (GPT-4)</option>
                    <option value="anthropic">Anthropic (Claude)</option>
                </select>
            </div>
            
            <div class="modal-section">
                <label class="modal-label">API Key</label>
                <input type="password" class="modal-input" id="apiKey" placeholder="Enter your API key...">
                <div style="font-size: 0.75em; color: var(--text-muted); margin-top: 6px;">
                    Your API key is stored locally in your browser and never sent anywhere except the AI provider.
                </div>
            </div>
            
            <div class="modal-section" id="openaiModelSection">
                <label class="modal-label">OpenAI Model</label>
                <select class="modal-select" id="openaiModel">
                    <option value="gpt-4o">GPT-4o (Recommended)</option>
                    <option value="gpt-4o-mini">GPT-4o Mini (Faster, cheaper)</option>
                    <option value="gpt-4-turbo">GPT-4 Turbo</option>
                </select>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn" onclick="closeSettingsModal()">Cancel</button>
                <button class="modal-btn primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    <!-- Continuity Event Modal -->
    <div class="modal continuity-modal" id="continuityModal">
        <div class="modal-content">
            <div class="modal-title" id="continuityModalTitle">Add Continuity Event</div>
            
            <div class="modal-section">
                <label class="modal-label">Event Type</label>
                <select class="modal-select" id="eventType">
                    <option value="wound">ðŸ©¹ Wound/Injury</option>
                    <option value="illness">ðŸ¤’ Illness</option>
                    <option value="aging">ðŸ‘´ Aging (Time Jump)</option>
                    <option value="deaging">ðŸ‘¶ De-aging (Flashback)</option>
                    <option value="pregnancy">ðŸ¤° Pregnancy</option>
                    <option value="dirt">ðŸ’§ Dirt/Grime</option>
                    <option value="costume">ðŸ‘” Costume Damage</option>
                    <option value="hair">âœ‚ï¸ Hair Change</option>
                    <option value="other">âš¡ Other</option>
                </select>
            </div>
            
            <div class="modal-section">
                <label class="modal-label">Description</label>
                <input type="text" class="modal-input" id="eventDescription" placeholder="e.g., Black eye from punch, Broken left arm, Muddy from fall...">
            </div>
            
            <div class="modal-section">
                <label class="modal-label">Scene Range</label>
                <div class="scene-range-inputs">
                    <div>
                        <label class="modal-label" style="font-size: 0.75em;">Start Scene</label>
                        <select class="modal-select" id="eventStartScene"></select>
                    </div>
                    <div>
                        <label class="modal-label" style="font-size: 0.75em;">End Scene</label>
                        <select class="modal-select" id="eventEndScene"></select>
                    </div>
                </div>
            </div>
            
            <div class="modal-section">
                <label class="modal-label">Timeline Context (Optional)</label>
                <div class="timeline-input-group">
                    <input type="text" class="modal-input" id="eventStartDay" placeholder="e.g., Day 1, Week 2, 5 years later...">
                    <input type="text" class="modal-input" id="eventEndDay" placeholder="End time...">
                </div>
            </div>
            
            <button class="ai-suggest-btn" onclick="generateProgression()" id="aiProgressionBtn">
                âœ¨ AI Generate Progression
            </button>
            
            <div class="modal-section">
                <label class="modal-label">Progression Stages</label>
                <div class="progression-list" id="progressionList">
                    <div style="color: var(--text-muted); font-size: 0.8125em; text-align: center; padding: 20px;">
                        Click "AI Generate Progression" to get suggested stages, or the event will apply uniformly across all scenes.
                    </div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn" onclick="closeContinuityModal()">Cancel</button>
                <button class="modal-btn primary" onclick="saveContinuityEvent()">Save Event</button>
            </div>
        </div>
    </div>

    <!-- Tag Popup -->
    <div class="tag-popup" id="tagPopup">
        <div class="tag-popup-header">
            <div class="tag-popup-title">Tag Selection</div>
            <button class="tag-popup-close" onclick="closeTagPopup()">Ã—</button>
        </div>

        <div class="tag-popup-body">
            <div class="tag-field">
                <label>Selected Text</label>
                <div class="tag-selected-text" id="tagSelectedText"></div>
            </div>

            <div class="tag-field">
                <label>Category</label>
                <select id="tagCategory" onchange="handleCategoryChange()">
                    <option value="hair">ðŸ’‡ Hair</option>
                    <option value="makeup">ðŸ’„ Makeup (Beauty)</option>
                    <option value="sfx">ðŸ©¸ SFX Makeup</option>
                    <option value="health">ðŸ¤’ Health/Illness</option>
                    <option value="injuries">ðŸ©¹ Injuries/Wounds</option>
                    <option value="stunts">ðŸŽ¬ Stunts/Action</option>
                    <option value="weather">ðŸŒ¦ï¸ Weather Effects</option>
                    <option value="wardrobe">ðŸ‘” Costume/Wardrobe</option>
                    <option value="extras">ðŸ‘¥ Supporting Artists (Extras)</option>
                </select>
            </div>

            <div class="tag-field" id="characterField" style="display: none;">
                <label>Assign to Character <span style="color: var(--error);">*</span></label>
                <select id="tagCharacter">
                    <option value="">-- Select Character --</option>
                </select>
            </div>

            <div class="tag-field">
                <label>Full Context (editable)</label>
                <textarea id="tagContext" rows="3" placeholder="Edit the captured context..."></textarea>
            </div>

            <div class="tag-field">
                <label>Continuity Options</label>
                <div class="tag-radio-group">
                    <label class="tag-radio">
                        <input type="radio" name="continuity" value="oneoff" checked>
                        <span>One-off (this scene only)</span>
                    </label>
                    <label class="tag-radio">
                        <input type="radio" name="continuity" value="create">
                        <span>Create new continuity event</span>
                    </label>
                    <label class="tag-radio" id="linkExistingOption" style="display: none;">
                        <input type="radio" name="continuity" value="link">
                        <span>Link to existing event</span>
                    </label>
                </div>

                <select id="existingEvents" style="display: none; margin-top: 8px;">
                    <option value="">-- Select Event --</option>
                </select>
            </div>
        </div>

        <div class="tag-popup-footer">
            <button class="modal-btn" onclick="closeTagPopup()">Cancel</button>
            <button class="modal-btn primary" onclick="saveTag()">Tag It</button>
        </div>
    </div>

    <!-- Tag Context Menu -->
    <div class="tag-context-menu" id="tagContextMenu" style="display: none;">
        <div class="context-menu-item" onclick="editTagFromContext()">
            âœï¸ Edit Tag
        </div>
        <div class="context-menu-item" onclick="removeTagFromContext()">
            ðŸ—‘ï¸ Remove Tag
        </div>
        <div class="context-menu-item" onclick="jumpToTagsTab()">
            ðŸ“‹ View in Tags Tab
        </div>
        <div class="context-menu-item" onclick="linkToContinuityFromContext()">
            âš¡ Link to Continuity
        </div>
    </div>

    <!-- Merge Characters Modal -->
    <div class="modal" id="mergeCharactersModal">
        <div class="modal-content">
            <div class="modal-title">Merge Duplicate Characters</div>
            <p style="font-size: 0.875em; color: var(--text-muted); margin-bottom: 16px;">
                Select two characters to merge. All scenes, tags, and data from the second character will be moved to the first.
            </p>

            <div class="modal-section">
                <label class="modal-label">Keep This Character (Primary)</label>
                <select class="modal-select" id="mergePrimaryCharacter">
                    <option value="">-- Select Character --</option>
                </select>
            </div>

            <div class="modal-section">
                <label class="modal-label">Merge This Character Into Primary (Will be deleted)</label>
                <select class="modal-select" id="mergeSecondaryCharacter">
                    <option value="">-- Select Character --</option>
                </select>
            </div>

            <div class="modal-actions">
                <button class="modal-btn" onclick="closeMergeCharactersModal()">Cancel</button>
                <button class="modal-btn primary" onclick="confirmMergeCharacters()">Merge Characters</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentProject = null;
        let scenes = [];
        let characters = new Set();
        let currentScene = null;
        let sceneBreakdowns = {};
        let castProfiles = {};
        let characterStates = {}; // { sceneIndex: { characterName: { tags: [], notes: '' } } }
        let characterLooks = {}; // { characterName: [{ id, lookName, scenes: [], storyTime, appearance: {}, scriptEvidence: {}, complexity, mustMatchScenes, storyContext }] }
        let continuityEvents = {}; // { characterName: [{ id, type, description, startScene, endScene, progression: [] }] }
        let sceneTimeline = {}; // { sceneIndex: { day: 1, time: "Morning", label: "Day 1 - Morning" } }
        let scriptText = '';
        let currentElementCategory = null;
        let currentCastMember = null;
        let currentTagCharacter = null;
        let currentEventCharacter = null;
        let currentEditingEvent = null;
        let activeTab = 'breakdown';
        let scriptTags = {}; // { sceneIndex: [ tag objects ] }
        let currentSelection = null;
        let activeCenterTab = 'script'; // Track active center tab
        let characterTabs = []; // List of character names with tabs

        // AI Settings
        let aiProvider = localStorage.getItem('aiProvider') || 'openai';
        let apiKey = localStorage.getItem('apiKey') || '';
        let openaiModel = localStorage.getItem('openaiModel') || 'gpt-4o';
        
        // Element categories
        const categories = [
            { id: 'cast', name: 'Cast Members', color: '#fbbf24', icon: 'ðŸ‘¤' },
            { id: 'hair', name: 'Hair', color: '#a855f7', icon: 'ðŸ’‡' },
            { id: 'makeup', name: 'Makeup (Beauty)', color: '#ec4899', icon: 'ðŸ’„' },
            { id: 'sfx', name: 'SFX Makeup', color: '#ef4444', icon: 'ðŸ©¸' },
            { id: 'health', name: 'Health/Illness', color: '#f59e0b', icon: 'ðŸ¤’' },
            { id: 'injuries', name: 'Injuries/Wounds', color: '#dc2626', icon: 'ðŸ©¹' },
            { id: 'stunts', name: 'Stunts/Action', color: '#f97316', icon: 'ðŸŽ¬' },
            { id: 'weather', name: 'Weather Effects', color: '#38bdf8', icon: 'ðŸŒ¦ï¸' },
            { id: 'wardrobe', name: 'Costume/Wardrobe', color: '#34d399', icon: 'ðŸ‘”' },
            { id: 'extras', name: 'Supporting Artists', color: '#9ca3af', icon: 'ðŸ‘¥' }
        ];
        
        // Continuity event types
        const eventTypes = [
            { id: 'wound', name: 'Wound/Injury', icon: 'ðŸ©¹', color: '#ef4444' },
            { id: 'illness', name: 'Illness', icon: 'ðŸ¤’', color: '#f59e0b' },
            { id: 'aging', name: 'Aging (Time Jump)', icon: 'ðŸ‘´', color: '#6b7280' },
            { id: 'deaging', name: 'De-aging (Flashback)', icon: 'ðŸ‘¶', color: '#8b5cf6' },
            { id: 'pregnancy', name: 'Pregnancy', icon: 'ðŸ¤°', color: '#ec4899' },
            { id: 'dirt', name: 'Dirt/Grime', icon: 'ðŸ’§', color: '#78716c' },
            { id: 'costume', name: 'Costume Damage', icon: 'ðŸ‘”', color: '#34d399' },
            { id: 'hair', name: 'Hair Change', icon: 'âœ‚ï¸', color: '#a855f7' },
            { id: 'other', name: 'Other', icon: 'âš¡', color: '#667eea' }
        ];

        // Name normalization and matching
        function normalizeCastName(name) {
            if (!name || typeof name !== 'string') return '';

            // Convert to uppercase and trim
            name = name.trim().toUpperCase();

            // Remove common suffixes like (V.O.), (O.S.), (CONT'D)
            name = name.replace(/\s*\(.*?\)\s*/g, '');

            return name;
        }

        function findMatchingCastMember(name, existingCast) {
            const normalized = normalizeCastName(name);
            if (!normalized) return null;

            // Check for exact match first
            const exactMatch = existingCast.find(c => normalizeCastName(c) === normalized);
            if (exactMatch) return exactMatch;

            // Split into parts for partial matching
            const nameParts = normalized.split(/\s+/);
            const firstName = nameParts[0];

            for (let existing of existingCast) {
                const existingParts = normalizeCastName(existing).split(/\s+/);
                const existingFirstName = existingParts[0];

                // If first names match
                if (firstName === existingFirstName) {
                    // Prefer the longer, more complete name
                    if (nameParts.length > existingParts.length) {
                        // New name is more complete, suggest using it to replace existing
                        return existing; // Return existing to merge into
                    } else {
                        // Existing name is more complete or equal
                        return existing;
                    }
                }

                // Check if new name contains all parts of existing name
                if (existingParts.every(part => nameParts.includes(part))) {
                    return existing;
                }

                // Check if existing name contains all parts of new name
                if (nameParts.every(part => existingParts.includes(part))) {
                    return existing;
                }
            }

            return null;
        }

        function mergeCharacterNames(oldName, newName) {
            // Use the longer name as it's likely more complete
            const oldNormalized = normalizeCastName(oldName);
            const newNormalized = normalizeCastName(newName);

            if (newNormalized.length > oldNormalized.length) {
                return newName;
            }
            return oldName;
        }

        function renameCharacterEverywhere(oldName, newName) {
            console.log(`Renaming "${oldName}" to "${newName}" everywhere`);

            // Update all scene breakdowns
            Object.keys(sceneBreakdowns).forEach(sceneIndex => {
                const breakdown = sceneBreakdowns[sceneIndex];
                if (breakdown.cast) {
                    const index = breakdown.cast.indexOf(oldName);
                    if (index !== -1) {
                        breakdown.cast[index] = newName;
                    }
                }
            });

            // Update character states
            Object.keys(characterStates).forEach(sceneIndex => {
                if (characterStates[sceneIndex][oldName]) {
                    characterStates[sceneIndex][newName] = characterStates[sceneIndex][oldName];
                    delete characterStates[sceneIndex][oldName];
                }
            });

            // Update continuity events
            if (continuityEvents[oldName]) {
                continuityEvents[newName] = continuityEvents[oldName];
                delete continuityEvents[oldName];
            }

            // Update cast profiles
            if (castProfiles[oldName]) {
                castProfiles[newName] = castProfiles[oldName];
                castProfiles[newName].name = newName;
                delete castProfiles[oldName];
            }

            // Update script tags
            Object.keys(scriptTags).forEach(sceneIndex => {
                scriptTags[sceneIndex].forEach(tag => {
                    if (tag.character === oldName) {
                        tag.character = newName;
                    }
                });
            });

            // Update scene.characters data
            scenes.forEach(scene => {
                if (scene.characters && scene.characters[oldName]) {
                    scene.characters[newName] = scene.characters[oldName];
                    delete scene.characters[oldName];
                }
            });
        }

        function cleanupDuplicateCharacters() {
            console.log('Checking for duplicate characters...');

            // Get all unique cast members across all scenes
            const allCast = new Set();
            Object.values(sceneBreakdowns).forEach(breakdown => {
                if (breakdown.cast) {
                    breakdown.cast.forEach(member => allCast.add(member));
                }
            });

            const castArray = Array.from(allCast);
            const merges = [];

            // Find duplicates
            for (let i = 0; i < castArray.length; i++) {
                for (let j = i + 1; j < castArray.length; j++) {
                    const name1 = castArray[i];
                    const name2 = castArray[j];

                    const normalized1 = normalizeCastName(name1);
                    const normalized2 = normalizeCastName(name2);

                    // Check if they're the same person
                    const parts1 = normalized1.split(/\s+/);
                    const parts2 = normalized2.split(/\s+/);

                    // If first names match, they're likely the same person
                    if (parts1[0] === parts2[0]) {
                        // Use the longer name
                        const keepName = parts1.length >= parts2.length ? name1 : name2;
                        const removeName = keepName === name1 ? name2 : name1;

                        merges.push({ keep: keepName, remove: removeName });
                    }
                }
            }

            // Apply merges
            merges.forEach(({ keep, remove }) => {
                console.log(`Merging "${remove}" into "${keep}"`);
                renameCharacterEverywhere(remove, keep);
            });

            if (merges.length > 0) {
                console.log(`âœ“ Merged ${merges.length} duplicate character(s)`);
                saveProject();
            }
        }

        // Initialize
        function init() {
            currentProject = JSON.parse(localStorage.getItem('currentProject') || 'null');
            
            if (!currentProject) {
                currentProject = { name: 'Untitled Project', id: Date.now() };
            }
            
            document.getElementById('projectTitle').textContent = currentProject.name + ' - Script Breakdown';
            
            // Check if API key is set
            if (!apiKey) {
                setTimeout(() => {
                    if (confirm('AI features require an API key. Would you like to set one up now?')) {
                        openSettingsModal();
                    }
                }, 1000);
            }
            
            if (!currentProject.scriptContent) {
                setTimeout(() => openImportModal(), 500);
            } else {
                loadScript(currentProject.scriptContent);
                
                if (currentProject.sceneBreakdowns) sceneBreakdowns = currentProject.sceneBreakdowns;
                if (currentProject.castProfiles) castProfiles = currentProject.castProfiles;
                if (currentProject.characterStates) characterStates = currentProject.characterStates;
                if (currentProject.characterLooks) characterLooks = currentProject.characterLooks;
                if (currentProject.continuityEvents) continuityEvents = currentProject.continuityEvents;
                if (currentProject.sceneTimeline) sceneTimeline = currentProject.sceneTimeline;
                if (currentProject.scriptTags) scriptTags = currentProject.scriptTags;

                // Clean up duplicate characters on load
                cleanupDuplicateCharacters();

                // Initialize character tabs with loaded data
                initializeCharacterTabs();

                renderSceneList();
                renderAllHighlights();
            }
            
            document.getElementById('sceneSearch').addEventListener('input', handleSceneSearch);

            // Keyboard shortcuts for scene navigation
            document.addEventListener('keydown', (e) => {
                // Alt+Left Arrow: Previous scene
                if (e.altKey && e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (currentScene !== null && currentScene > 0) {
                        navigateToScene(currentScene - 1);
                    }
                }
                // Alt+Right Arrow: Next scene
                if (e.altKey && e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (currentScene !== null && currentScene < scenes.length - 1) {
                        navigateToScene(currentScene + 1);
                    }
                }
            });
        }

        // Settings Modal
        function openSettingsModal() {
            document.getElementById('aiProvider').value = aiProvider;
            document.getElementById('apiKey').value = apiKey;
            document.getElementById('openaiModel').value = openaiModel;
            document.getElementById('settingsModal').classList.add('active');
        }
        
        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.remove('active');
        }
        
        function saveSettings() {
            aiProvider = document.getElementById('aiProvider').value;
            apiKey = document.getElementById('apiKey').value.trim();
            openaiModel = document.getElementById('openaiModel').value;
            
            if (!apiKey) {
                alert('Please enter an API key');
                return;
            }
            
            localStorage.setItem('aiProvider', aiProvider);
            localStorage.setItem('apiKey', apiKey);
            localStorage.setItem('openaiModel', openaiModel);
            
            closeSettingsModal();
            alert('AI settings saved! You can now use AI features.');
        }
        
        // Universal AI Call Function
        async function callAI(prompt, maxTokens = 500) {
            // For deployed Vercel version - call secure serverless function
            if (window.location.hostname.includes('vercel.app')) {
                try {
                    const response = await fetch("/api/ai", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            messages: [{
                                role: "user",
                                content: prompt
                            }],
                            maxTokens: maxTokens
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(`API returned ${response.status}: ${JSON.stringify(data)}`);
                    }
                    
                    // Extract text from response
                    if (data.choices && data.choices[0] && data.choices[0].message) {
                        return data.choices[0].message.content;
                    }
                    
                    throw new Error('Invalid response format from API');
                    
                } catch (error) {
                    console.error('Serverless API Error:', error);
                    throw error;
                }
            }
            
            // For local testing with API key - INSECURE, only for testing!
            if (!apiKey) {
                throw new Error('No API key set. Please configure AI settings first or deploy to Vercel with serverless function.');
            }
            
            if (aiProvider === 'openai') {
                const response = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: openaiModel,
                        messages: [{
                            role: "user",
                            content: prompt
                        }],
                        max_tokens: maxTokens,
                        temperature: 0.7
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('OpenAI API Error:', errorText);
                    throw new Error(`OpenAI API returned ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    throw new Error('Invalid response format from OpenAI');
                }
                
                return data.choices[0].message.content;
                
            } else if (aiProvider === 'anthropic') {
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "x-api-key": apiKey,
                        "anthropic-version": "2023-06-01"
                    },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: maxTokens,
                        messages: [{
                            role: "user",
                            content: prompt
                        }]
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Anthropic API Error:', errorText);
                    throw new Error(`Anthropic API returned ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                if (!data.content || !data.content[0]) {
                    throw new Error('Invalid response format from Anthropic');
                }
                
                return data.content[0].text;
            }
        }
        
        // Scene type detection FOR VISUAL STYLING ONLY
        // This combines INT/EXT + DAY/NIGHT for color-coding the scene cards
        // The actual metadata uses separate fields: intExt and timeOfDay
        function getSceneType(heading) {
            const h = heading.toUpperCase();
            const isInt = h.includes('INT.');
            const isExt = h.includes('EXT.');
            const isDay = h.includes('DAY') || h.includes('MORNING') || h.includes('AFTERNOON');
            const isNight = h.includes('NIGHT') || h.includes('EVENING') || h.includes('DUSK');
            
            if (isInt && isDay) return 'int-day';
            if (isExt && isDay) return 'ext-day';
            if (isInt && isNight) return 'int-night';
            if (isExt && isNight) return 'ext-night';
            return 'int-day';
        }

        function getSceneTypeLabel(sceneType) {
            const labels = {
                'int-day': 'INT / DAY',
                'ext-day': 'EXT / DAY',
                'int-night': 'INT / NIGHT',
                'ext-night': 'EXT / NIGHT'
            };
            return labels[sceneType] || '';
        }

        // ========================================
        // Character Tab Management
        // ========================================

        function initializeCharacterTabs() {
            // Clean up first
            cleanupCastProfiles();

            // Get all unique characters that are ACTUAL cast members (in scene breakdowns)
            const actualCastMembers = new Set();

            // Collect cast members from all scene breakdowns
            Object.values(sceneBreakdowns).forEach(breakdown => {
                if (breakdown.cast && Array.isArray(breakdown.cast)) {
                    breakdown.cast.forEach(member => {
                        // Only add if it's a real character name (not empty, reasonable length)
                        if (member && typeof member === 'string' && member.length >= 2 && member.length <= 50) {
                            actualCastMembers.add(member);
                        }
                    });
                }
            });

            // Only create tabs for characters who are actual cast members
            characterTabs = Array.from(actualCastMembers).sort();

            console.log('Character tabs initialized:', characterTabs);
            renderCharacterTabs();
        }

        function cleanupCastProfiles() {
            // Get actual cast members from breakdowns
            const actualCast = new Set();
            Object.values(sceneBreakdowns).forEach(breakdown => {
                if (breakdown.cast) {
                    breakdown.cast.forEach(member => actualCast.add(member));
                }
            });

            // Remove profiles for non-cast entries (but keep the data in case)
            Object.keys(castProfiles).forEach(name => {
                if (!actualCast.has(name)) {
                    // Optional: Delete orphaned profiles, or just skip them in tab creation
                    // delete castProfiles[name]; // Uncomment if you want to delete orphans
                    console.log('Skipping non-cast profile:', name);
                }
            });
        }

        function renderCharacterTabs() {
            const tabsContainer = document.querySelector('.center-tabs');
            if (!tabsContainer) return;

            // Keep script tab
            const scriptTab = tabsContainer.querySelector('[data-tab="script"]');

            // Remove everything except script tab
            tabsContainer.innerHTML = '';
            if (scriptTab) {
                tabsContainer.appendChild(scriptTab);
            }

            // Add character tabs (auto-generated from sceneBreakdowns)
            characterTabs.forEach(character => {
                const tab = document.createElement('div');
                tab.className = 'center-tab';
                tab.setAttribute('data-tab', `character-${character}`);
                tab.onclick = () => switchCenterTab(`character-${character}`);
                tab.innerHTML = `
                    <span>ðŸ‘¤ ${character}</span>
                    <span class="center-tab-close" onclick="event.stopPropagation(); removeCharacterTab('${character.replace(/'/g, "\\'")}')">Ã—</span>
                `;
                tabsContainer.appendChild(tab);
            });

            // Create tab panels for each character
            renderCharacterTabPanels();
        }

        function renderCharacterTabPanels() {
            const contentContainer = document.querySelector('.center-tab-content');
            if (!contentContainer) return;

            // Remove old character panels (keep script panel)
            const panels = contentContainer.querySelectorAll('[id^="characterTab-"]');
            panels.forEach(panel => panel.remove());

            // Create new panels
            characterTabs.forEach(character => {
                const panel = document.createElement('div');
                panel.className = 'center-tab-panel';
                panel.id = `characterTab-${character}`;

                panel.innerHTML = renderCharacterTimeline(character);

                contentContainer.appendChild(panel);
            });
        }

        function switchCenterTab(tabName) {
            activeCenterTab = tabName;

            // Update tab styling
            document.querySelectorAll('.center-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`)?.classList.add('active');

            // Update panel visibility
            document.querySelectorAll('.center-tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });

            if (tabName === 'script') {
                document.getElementById('scriptTabPanel')?.classList.add('active');
            } else {
                const character = tabName.replace('character-', '');
                document.getElementById(`characterTab-${character}`)?.classList.add('active');

                // Setup image upload handlers and load existing images for character timeline
                setTimeout(() => {
                    setupDayImageUpload();
                    loadDayImages(character);
                }, 100);
            }

            // Update right panel context
            updateRightPanelContext();
        }

        function updateRightPanelContext() {
            const rightSidebar = document.querySelector('.right-sidebar');
            if (!rightSidebar) return;

            if (activeCenterTab === 'script') {
                // Script tab active - restore original structure
                const existingTabs = rightSidebar.querySelector('.workspace-tabs');
                if (!existingTabs || existingTabs.innerHTML.indexOf('Scene Breakdown') === -1) {
                    rightSidebar.innerHTML = `
                        <div class="workspace-tabs">
                            <div class="workspace-tab active" onclick="switchTab('breakdown')">Scene Breakdown</div>
                        </div>

                        <div class="workspace-content">
                            <div class="tab-panel active" id="breakdownPanel">
                                <div class="empty-state">
                                    <div class="empty-icon">ðŸ“‹</div>
                                    <div class="empty-title">Select a Scene</div>
                                    <div class="empty-desc">Choose a scene to view and edit its breakdown</div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Re-render panels if scene is selected
                    if (currentScene !== null) {
                        renderBreakdownPanel();
                    }
                }

            } else if (activeCenterTab.startsWith('character-')) {
                // Character tab active - show character-specific quick editor
                const characterName = activeCenterTab.replace('character-', '');
                renderCharacterQuickEditor(characterName);
            }
        }

        function renderCharacterQuickEditor(character) {
            const rightSidebar = document.querySelector('.right-sidebar');
            if (!rightSidebar) return;

            const profile = castProfiles[character] || { baseDescription: '' };

            // Get all scenes this character appears in
            const characterScenes = [];
            scenes.forEach((scene, index) => {
                const breakdown = sceneBreakdowns[index] || {};
                if (breakdown.cast && breakdown.cast.includes(character)) {
                    characterScenes.push({ scene, index });
                }
            });

            rightSidebar.innerHTML = `
                <div class="workspace-tabs">
                    <div class="workspace-tab active">
                        ðŸ‘¤ ${character}
                    </div>
                </div>

                <div class="workspace-content">
                    <div class="tab-panel active" style="padding: 20px; overflow-y: auto;">

                        <!-- Base Description -->
                        <div class="profile-section" style="margin-bottom: 24px;">
                            <label class="profile-label">Base Description</label>
                            <textarea class="modal-textarea"
                                      id="quickEditBaseDesc"
                                      rows="3"
                                      placeholder="Age, physical appearance, general characteristics..."
                                      onchange="updateQuickBaseDescription('${character.replace(/'/g, "\\'")}', this.value)">${profile.baseDescription || ''}</textarea>
                            <div style="font-size: 0.75em; color: var(--text-muted); margin-top: 6px;">
                                This applies to all ${characterScenes.length} scenes
                            </div>
                        </div>

                        <!-- Quick Stats -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 24px;">
                            <div style="padding: 12px; background: rgba(212, 175, 122, 0.08); border-radius: 8px; text-align: center;">
                                <div style="font-size: 1.5em; font-weight: 700; color: var(--accent-gold);">${characterScenes.length}</div>
                                <div style="font-size: 0.75em; color: var(--text-muted);">Scenes</div>
                            </div>
                            <div style="padding: 12px; background: rgba(212, 175, 122, 0.08); border-radius: 8px; text-align: center;">
                                <div style="font-size: 1.5em; font-weight: 700; color: var(--accent-gold);">${(continuityEvents[character] || []).length}</div>
                                <div style="font-size: 0.75em; color: var(--text-muted);">Events</div>
                            </div>
                        </div>

                        <!-- Scene Selector -->
                        ${currentScene !== null && characterScenes.some(cs => cs.index === currentScene) ? `
                            <div style="margin-bottom: 24px; padding: 16px; background: rgba(102, 126, 234, 0.08); border: 1px solid rgba(102, 126, 234, 0.3); border-radius: 8px;">
                                <div style="font-size: 0.875em; font-weight: 600; color: var(--accent-blue); margin-bottom: 12px;">
                                    ðŸ“ Currently Viewing Scene ${scenes[currentScene].number}
                                </div>
                                <div style="font-size: 0.8125em; color: var(--text-muted);">
                                    ${scenes[currentScene].heading}
                                </div>
                                <button class="modal-btn primary"
                                        style="width: 100%; margin-top: 12px;"
                                        onclick="switchCenterTab('script'); setTimeout(() => switchTab('breakdown'), 100)">
                                    Edit Scene Breakdown
                                </button>
                            </div>
                        ` : ''}

                        <!-- Actions -->
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <button class="modal-btn primary" onclick="openCastProfile('${character.replace(/'/g, "\\'")}')">
                                Open Full Profile
                            </button>
                            <button class="modal-btn" onclick="openContinuityModal('${character.replace(/'/g, "\\'")}')">
                                + Add Continuity Event
                            </button>
                            <button class="modal-btn" onclick="exportCharacterReport('${character.replace(/'/g, "\\'")}')">
                                ðŸ“„ Export Character Report
                            </button>
                        </div>

                        <!-- Recent Scenes Preview -->
                        ${characterScenes.length > 0 ? `
                            <div style="margin-top: 24px;">
                                <div style="font-size: 0.875em; font-weight: 600; color: var(--text-light); margin-bottom: 12px;">
                                    Recent Scenes
                                </div>
                                ${characterScenes.slice(0, 5).map(({ scene, index }) => {
                                    const sceneTags = scriptTags[index] || [];
                                    const characterTags = sceneTags.filter(t => t.character === character);
                                    return `
                                        <div style="padding: 10px 12px; background: rgba(28, 25, 22, 0.3); border: 1px solid var(--glass-border); border-radius: 6px; margin-bottom: 6px; cursor: pointer;"
                                             onclick="jumpToSceneFromTimeline(${index})">
                                            <div style="font-size: 0.8125em; font-weight: 600; color: var(--text-light);">
                                                Scene ${scene.number}
                                            </div>
                                            <div style="font-size: 0.75em; color: var(--text-muted);">
                                                ${scene.heading.substring(0, 40)}...
                                            </div>
                                            ${characterTags.length > 0 ? `
                                                <div style="font-size: 0.6875em; color: var(--accent-gold); margin-top: 4px;">
                                                    ${characterTags.length} tags
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }).join('')}
                                ${characterScenes.length > 5 ? `
                                    <div style="text-align: center; margin-top: 8px;">
                                        <button class="modal-btn" onclick="switchCenterTab('character-${character}')">
                                            View All ${characterScenes.length} Scenes
                                        </button>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                    </div>
                </div>
            `;
        }

        function updateQuickBaseDescription(character, value) {
            if (!castProfiles[character]) {
                castProfiles[character] = { name: character };
            }
            castProfiles[character].baseDescription = value;
            saveProject();
        }

        function exportCharacterReport(character) {
            alert(`Character report export for ${character} - Coming in Phase 2!`);
        }

        function removeCharacterTab(character) {
            if (!confirm(`Remove ${character}'s tab? (Character data will be preserved)`)) return;

            characterTabs = characterTabs.filter(c => c !== character);
            renderCharacterTabs();

            // Switch to script tab if we just closed the active tab
            if (activeCenterTab === `character-${character}`) {
                switchCenterTab('script');
            }
        }

        // ===== STORY DAY TIMELINE HELPER FUNCTIONS =====

        // Group scenes by story day for a character
        function getStoryDaysForCharacter(character) {
            const storyDays = new Map();

            scenes.forEach((scene, index) => {
                const breakdown = sceneBreakdowns[index] || {};

                // Only include scenes where character appears
                if (!breakdown.cast || !breakdown.cast.includes(character)) return;

                const dayLabel = scene.storyDay || `Scene ${scene.number}`;

                if (!storyDays.has(dayLabel)) {
                    storyDays.set(dayLabel, {
                        label: dayLabel,
                        scenes: [],
                        timeOfDay: scene.timeOfDay || 'Unknown'
                    });
                }

                storyDays.get(dayLabel).scenes.push({
                    scene: scene,
                    index: index,
                    breakdown: breakdown
                });
            });

            return Array.from(storyDays.values());
        }

        // Aggregate look data for a story day
        function aggregateStoryDay(character, storyDayData) {
            const { scenes: dayScenes } = storyDayData;

            // Find the most detailed entry for each department field
            const aggregated = {
                hair: '',
                makeup: '',
                sfx: '',
                wardrobe: '',
                notes: ''
            };

            dayScenes.forEach(({ index }) => {
                const state = characterStates[index]?.[character] || {};

                // Use the longest/most detailed description
                if (state.hair && state.hair.length > aggregated.hair.length) {
                    aggregated.hair = state.hair;
                }
                if (state.makeup && state.makeup.length > aggregated.makeup.length) {
                    aggregated.makeup = state.makeup;
                }
                if (state.sfx && state.sfx.length > aggregated.sfx.length) {
                    aggregated.sfx = state.sfx;
                }
                if (state.wardrobe && state.wardrobe.length > aggregated.wardrobe.length) {
                    aggregated.wardrobe = state.wardrobe;
                }
                if (state.notes && state.notes.length > aggregated.notes.length) {
                    aggregated.notes = state.notes;
                }
            });

            return aggregated;
        }

        // Get active events for a specific story day
        function getActiveEventsForDay(character, dayLabel) {
            const events = continuityEvents[character] || [];

            // Find scenes in this story day
            const dayScenes = scenes.filter(s => (s.storyDay || `Scene ${s.number}`) === dayLabel);
            const daySceneIndices = dayScenes.map(s => scenes.indexOf(s));

            // Filter events that are active in ANY scene of this day
            return events.filter(event => {
                return daySceneIndices.some(sceneIdx => {
                    return sceneIdx >= event.startScene &&
                           (event.endScene === null || sceneIdx <= event.endScene);
                });
            });
        }

        // Calculate event progress for a story day
        function calculateEventProgress(event, dayLabel) {
            const dayScenes = scenes.filter(s => (s.storyDay || `Scene ${s.number}`) === dayLabel);
            if (dayScenes.length === 0) return 0;

            const firstSceneIndex = scenes.indexOf(dayScenes[0]);
            const totalScenes = event.endScene !== null
                ? (event.endScene - event.startScene + 1)
                : (scenes.length - event.startScene);
            const currentScene = firstSceneIndex - event.startScene;

            return Math.round((currentScene / totalScenes) * 100);
        }

        // Get event stage label
        function getEventStageLabel(progress) {
            if (progress < 33) return { label: 'Fresh', class: 'fresh' };
            if (progress < 75) return { label: 'Healing', class: 'healing' };
            return { label: 'Healed', class: 'healed' };
        }

        // Setup image upload for story day cards
        function setupDayImageUpload() {
            document.querySelectorAll('.reference-image-zone').forEach(zone => {
                zone.onclick = function() {
                    const character = activeCenterTab.replace('character-', '');
                    const dayLabel = this.closest('.story-day-card').dataset.dayLabel;

                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.onchange = function(e) {
                        const file = e.target.files[0];
                        if (file) {
                            // Check file size (max 2MB)
                            if (file.size > 2 * 1024 * 1024) {
                                alert('Image too large. Please use an image under 2MB.');
                                return;
                            }

                            const reader = new FileReader();
                            reader.onload = function(e) {
                                const base64 = e.target.result;
                                saveDayImage(character, dayLabel, base64);
                                updateImageDisplay(zone, base64);
                            };
                            reader.readAsDataURL(file);
                        }
                    };
                    input.click();
                };
            });
        }

        // Save image to character profile
        function saveDayImage(character, dayLabel, base64) {
            if (!castProfiles[character]) {
                castProfiles[character] = { name: character };
            }
            if (!castProfiles[character].storyDayImages) {
                castProfiles[character].storyDayImages = {};
            }

            castProfiles[character].storyDayImages[dayLabel] = base64;
            saveProject();
        }

        // Update image display in card
        function updateImageDisplay(zone, base64) {
            zone.innerHTML = `
                <img src="${base64}" class="day-reference-image" />
                <div class="image-overlay">
                    <button class="change-image-btn">Change Photo</button>
                </div>
            `;
        }

        // Load existing images on render
        function loadDayImages(character) {
            const profile = castProfiles[character];
            if (!profile || !profile.storyDayImages) return;

            Object.keys(profile.storyDayImages).forEach(dayLabel => {
                const zone = document.querySelector(`[data-day-label="${dayLabel}"] .reference-image-zone`);
                if (zone) {
                    updateImageDisplay(zone, profile.storyDayImages[dayLabel]);
                }
            });
        }

        // Toggle day card expansion
        function toggleDayExpansion(btn) {
            const card = btn.closest('.story-day-card');
            const expandedList = card.querySelector('.expanded-scene-list');

            if (expandedList.style.display === 'none' || !expandedList.style.display) {
                expandedList.style.display = 'block';
                btn.textContent = 'Hide Scenes â–²';
            } else {
                expandedList.style.display = 'none';
                btn.textContent = 'View Scenes â–¼';
            }
        }

        // Navigate to previous day
        function scrollToPreviousDay() {
            const timeline = document.querySelector('.story-day-timeline');
            if (!timeline) return;
            const cardWidth = 336; // 320px card + 16px gap
            timeline.scrollBy({ left: -cardWidth, behavior: 'smooth' });
        }

        // Navigate to next day
        function scrollToNextDay() {
            const timeline = document.querySelector('.story-day-timeline');
            if (!timeline) return;
            const cardWidth = 336;
            timeline.scrollBy({ left: cardWidth, behavior: 'smooth' });
        }

        // ===== END STORY DAY TIMELINE HELPER FUNCTIONS =====

        function renderCharacterTimeline(character) {
            const profile = castProfiles[character] || {};
            const storyDays = getStoryDaysForCharacter(character);

            // Calculate total scenes
            const totalScenes = storyDays.reduce((sum, day) => sum + day.scenes.length, 0);

            // Get continuity events for this character
            const events = continuityEvents[character] || [];

            // Build HTML - Story Day Card Timeline
            let html = `
                <div class="character-timeline-view">
                    <!-- Header -->
                    <div class="timeline-header">
                        <div class="character-info">
                            <div class="character-name-title">${character}</div>
                            <div class="character-base-info">${profile.baseDescription || '<em style="opacity: 0.6;">No description yet</em>'}</div>
                        </div>
                        <div class="timeline-stats">
                            <div class="stat">
                                <span class="stat-value">${storyDays.length}</span>
                                <span class="stat-label">Story Days</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">${totalScenes}</span>
                                <span class="stat-label">Scenes</span>
                            </div>
                            <div class="stat">
                                <span class="stat-value">${events.length}</span>
                                <span class="stat-label">Events</span>
                            </div>
                        </div>
                    </div>

                    <!-- Timeline Controls -->
                    <div class="timeline-controls">
                        <button class="nav-btn" onclick="scrollToPreviousDay()">â† Previous Day</button>
                        <div class="view-mode-switcher">
                            <button class="mode-btn active">Timeline</button>
                        </div>
                        <button class="nav-btn" onclick="scrollToNextDay()">Next Day â†’</button>
                    </div>

                    <!-- Story Day Cards -->
                    <div class="story-day-timeline">
            `;

            storyDays.forEach(dayData => {
                const aggregated = aggregateStoryDay(character, dayData);
                const activeEvents = getActiveEventsForDay(character, dayData.label);
                const hasImage = profile.storyDayImages?.[dayData.label];

                html += `
                    <div class="story-day-card" data-day-label="${dayData.label}">
                        <div class="day-card-header">
                            <div class="day-label">${dayData.label}</div>
                            <div class="scene-count">${dayData.scenes.length} scene${dayData.scenes.length !== 1 ? 's' : ''}</div>
                        </div>

                        <div class="reference-image-zone">
                            ${hasImage ? `
                                <img src="${profile.storyDayImages[dayData.label]}" class="day-reference-image" />
                                <div class="image-overlay">
                                    <button class="change-image-btn">Change Photo</button>
                                </div>
                            ` : `
                                <div class="image-placeholder">
                                    <span class="upload-icon">ðŸ“·</span>
                                    <span class="upload-text">+ Upload Reference</span>
                                </div>
                            `}
                        </div>

                        <div class="look-summary">
                            <div class="look-field ${aggregated.hair ? '' : 'empty'}">
                                <span class="field-icon">ðŸ’‡</span>
                                <span class="field-text">${aggregated.hair || 'â€”'}</span>
                            </div>
                            <div class="look-field ${aggregated.makeup ? '' : 'empty'}">
                                <span class="field-icon">ðŸ’„</span>
                                <span class="field-text">${aggregated.makeup || 'â€”'}</span>
                            </div>
                            <div class="look-field ${aggregated.sfx ? 'has-event' : 'empty'}">
                                <span class="field-icon">ðŸ©¸</span>
                                <span class="field-text">${aggregated.sfx || 'â€”'} ${aggregated.sfx && activeEvents.length > 0 ? '<span class="event-indicator">âš¡</span>' : ''}</span>
                            </div>
                            <div class="look-field ${aggregated.wardrobe ? '' : 'empty'}">
                                <span class="field-icon">ðŸ‘”</span>
                                <span class="field-text">${aggregated.wardrobe || 'â€”'}</span>
                            </div>
                        </div>

                        ${activeEvents.length > 0 ? `
                            <div class="active-events-badge">
                                <span class="event-icon">âš¡</span>
                                <span class="event-text">${activeEvents.length} active event${activeEvents.length !== 1 ? 's' : ''}</span>
                            </div>
                        ` : ''}

                        <button class="expand-day-btn" onclick="toggleDayExpansion(this)">
                            View Scenes â–¼
                        </button>

                        <div class="expanded-scene-list" style="display: none;">
                            ${dayData.scenes.map(({ scene, index }) => {
                                const state = characterStates[index]?.[character] || {};
                                const lookDetails = [];
                                if (state.hair) lookDetails.push(`Hair: ${state.hair}`);
                                if (state.makeup) lookDetails.push(`Makeup: ${state.makeup}`);
                                if (state.sfx) lookDetails.push(`SFX: ${state.sfx}`);
                                if (state.wardrobe) lookDetails.push(`Wardrobe: ${state.wardrobe}`);

                                return `
                                    <div class="scene-item" onclick="jumpToSceneFromTimeline(${index})">
                                        <div class="scene-number">Scene ${scene.number}</div>
                                        <div class="scene-heading">${scene.heading}</div>
                                        ${lookDetails.length > 0 ? `
                                            <div class="scene-look-detail">
                                                ${lookDetails.slice(0, 2).join(' | ')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            return html;
        }

        function jumpToSceneFromTimeline(sceneIndex) {
            // Switch to script tab
            switchCenterTab('script');

            // Select the scene
            selectScene(sceneIndex);

            // Scroll to scene in script viewer
            setTimeout(() => {
                const sceneEl = document.getElementById(`scene-${scenes[sceneIndex].number}`);
                if (sceneEl) {
                    sceneEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 100);
        }

        // Merge Characters Modal
        function openMergeCharactersModal() {
            // Get all cast members
            const allCast = new Set();
            Object.values(sceneBreakdowns).forEach(breakdown => {
                if (breakdown.cast) {
                    breakdown.cast.forEach(member => allCast.add(member));
                }
            });

            const castArray = Array.from(allCast).sort();

            if (castArray.length < 2) {
                alert('Need at least 2 cast members to merge.');
                return;
            }

            // Populate dropdowns
            const primary = document.getElementById('mergePrimaryCharacter');
            const secondary = document.getElementById('mergeSecondaryCharacter');

            primary.innerHTML = '<option value="">-- Select Character --</option>';
            secondary.innerHTML = '<option value="">-- Select Character --</option>';

            castArray.forEach(member => {
                const opt1 = document.createElement('option');
                opt1.value = member;
                opt1.textContent = member;
                primary.appendChild(opt1);

                const opt2 = document.createElement('option');
                opt2.value = member;
                opt2.textContent = member;
                secondary.appendChild(opt2);
            });

            document.getElementById('mergeCharactersModal').classList.add('active');
        }

        function closeMergeCharactersModal() {
            document.getElementById('mergeCharactersModal').classList.remove('active');
        }

        function confirmMergeCharacters() {
            const primaryName = document.getElementById('mergePrimaryCharacter').value;
            const secondaryName = document.getElementById('mergeSecondaryCharacter').value;

            if (!primaryName || !secondaryName) {
                alert('Please select both characters.');
                return;
            }

            if (primaryName === secondaryName) {
                alert('Cannot merge a character with itself.');
                return;
            }

            if (!confirm(`Merge "${secondaryName}" into "${primaryName}"?\n\nAll data from ${secondaryName} will be moved to ${primaryName}, and ${secondaryName} will be deleted.`)) {
                return;
            }

            console.log(`Merging ${secondaryName} into ${primaryName}`);

            // Merge in scene breakdowns
            Object.keys(sceneBreakdowns).forEach(sceneIndex => {
                const breakdown = sceneBreakdowns[sceneIndex];
                if (breakdown.cast) {
                    const secondaryIndex = breakdown.cast.indexOf(secondaryName);
                    if (secondaryIndex !== -1) {
                        // Remove secondary
                        breakdown.cast.splice(secondaryIndex, 1);

                        // Add primary if not already there
                        if (!breakdown.cast.includes(primaryName)) {
                            breakdown.cast.push(primaryName);
                        }
                    }
                }
            });

            // Merge character states
            Object.keys(characterStates).forEach(sceneIndex => {
                if (characterStates[sceneIndex][secondaryName]) {
                    if (!characterStates[sceneIndex][primaryName]) {
                        characterStates[sceneIndex][primaryName] = characterStates[sceneIndex][secondaryName];
                    } else {
                        // Merge tags
                        const secondaryTags = characterStates[sceneIndex][secondaryName].tags || [];
                        const primaryTags = characterStates[sceneIndex][primaryName].tags || [];
                        characterStates[sceneIndex][primaryName].tags = [...primaryTags, ...secondaryTags];
                    }
                    delete characterStates[sceneIndex][secondaryName];
                }
            });

            // Merge continuity events
            if (continuityEvents[secondaryName]) {
                if (!continuityEvents[primaryName]) {
                    continuityEvents[primaryName] = continuityEvents[secondaryName];
                } else {
                    continuityEvents[primaryName] = [...continuityEvents[primaryName], ...continuityEvents[secondaryName]];
                }
                delete continuityEvents[secondaryName];
            }

            // Merge cast profiles
            if (castProfiles[secondaryName]) {
                if (!castProfiles[primaryName]) {
                    castProfiles[primaryName] = castProfiles[secondaryName];
                    castProfiles[primaryName].name = primaryName;
                } else {
                    // Merge scenes
                    const secondaryScenes = castProfiles[secondaryName].scenes || [];
                    const primaryScenes = castProfiles[primaryName].scenes || [];
                    castProfiles[primaryName].scenes = [...new Set([...primaryScenes, ...secondaryScenes])];

                    // Merge descriptions if primary is empty
                    if (!castProfiles[primaryName].baseDescription && castProfiles[secondaryName].baseDescription) {
                        castProfiles[primaryName].baseDescription = castProfiles[secondaryName].baseDescription;
                    }
                }
                delete castProfiles[secondaryName];
            }

            // Merge tags
            Object.keys(scriptTags).forEach(sceneIndex => {
                scriptTags[sceneIndex].forEach(tag => {
                    if (tag.character === secondaryName) {
                        tag.character = primaryName;
                    }
                });
            });

            // Merge scene.characters data
            scenes.forEach(scene => {
                if (scene.characters && scene.characters[secondaryName]) {
                    if (!scene.characters[primaryName]) {
                        scene.characters[primaryName] = scene.characters[secondaryName];
                    }
                    delete scene.characters[secondaryName];
                }
            });

            saveProject();

            // Refresh UI
            initializeCharacterTabs();
            renderSceneList();
            if (currentScene !== null) {
                renderBreakdownPanel();
                renderCastPanel();
            }

            closeMergeCharactersModal();

            alert(`Successfully merged "${secondaryName}" into "${primaryName}"`);
        }

        // Load script
        function loadScript(text) {
            scriptText = text;
            
            if (currentProject.scenes && Array.isArray(currentProject.scenes) && currentProject.scenes.length > 0) {
                scenes = currentProject.scenes;
            } else {
                scenes = detectScenes(text);
            }
            
            characters = detectCharacters(text);
            
            document.getElementById('sceneCount').textContent = scenes.length;
            
            renderSceneList();
            renderScript();

            currentProject.scenes = scenes;
            currentProject.sceneCount = scenes.length;
            currentProject.characters = Array.from(characters);
            saveProject();
        }
        
        // Detect scenes
        function detectScenes(text) {
            const lines = text.split('\n');
            const detected = [];
            
            const patterns = [
                /^(\d+\.?\s*)?(INT\.|EXT\.|INT\/EXT\.|I\/E\.).*$/i,
                /^(INT|EXT)\s+[-â€“â€”]\s+.+$/i
            ];
            
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                for (let pattern of patterns) {
                    if (pattern.test(trimmed)) {
                        const sceneIndex = detected.length;
                        detected.push({
                            number: sceneIndex + 1,
                            heading: trimmed,
                            lineNumber: index,
                            synopsis: null,
                            storyDay: '',
                            timeOfDay: detectTimeOfDay(trimmed, sceneIndex),
                            intExt: detectIntExt(trimmed),
                            location: extractLocation(trimmed, sceneIndex),
                            characters: {}
                        });
                        break;
                    }
                }
            });
            
            return detected;
        }
        
        // Detect characters
        function detectCharacters(text) {
            const lines = text.split('\n');
            const chars = new Set();
            const exclude = ['FADE IN', 'FADE OUT', 'CUT TO', 'DISSOLVE TO', 'THE END', 'CONTINUED'];
            
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (trimmed && 
                    trimmed === trimmed.toUpperCase() && 
                    trimmed.length < 30 && 
                    trimmed.length > 1 &&
                    !trimmed.includes('.') &&
                    !trimmed.includes(':') &&
                    !exclude.some(word => trimmed.includes(word))) {
                    
                    const nextLine = lines[index + 1] ? lines[index + 1].trim() : '';
                    if (nextLine && nextLine !== nextLine.toUpperCase()) {
                        const cleaned = trimmed.replace(/\(.*\)/, '').trim();
                        if (cleaned) chars.add(cleaned);
                    }
                }
            });
            
            return chars;
        }
        
        // Detect character introductions
        async function detectCharacterIntroductions(text) {
            const lines = text.split('\n');
            const introductions = {};
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for ALL CAPS names in action lines
                const capsWords = line.match(/\b([A-Z][A-Z\s]{2,25})\b/g);
                if (!capsWords) continue;
                
                for (let capsWord of capsWords) {
                    const cleaned = capsWord.trim();
                    
                    // Skip if already found
                    if (introductions[cleaned]) continue;
                    
                    // Skip common screenplay terms
                    if (['FADE IN', 'FADE OUT', 'CUT TO', 'INT', 'EXT', 'DAY', 'NIGHT', 'CONTINUED'].includes(cleaned)) continue;
                    
                    // Check if this is followed by dialogue (not a character name)
                    const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';
                    if (nextLine && nextLine !== nextLine.toUpperCase()) {
                        // This might be a character intro
                        let description = '';
                        
                        // Check for parenthetical description
                        const parenMatch = line.match(new RegExp(cleaned + '\\s*\\(([^)]+)\\)'));
                        if (parenMatch) {
                            description = parenMatch[1].trim();
                        } else {
                            // Look for description in surrounding lines
                            const surroundingText = [line];
                            for (let j = i + 1; j < Math.min(i + 4, lines.length); j++) {
                                const nextL = lines[j].trim();
                                if (!nextL || nextL === nextL.toUpperCase()) break;
                                surroundingText.push(nextL);
                            }
                            description = surroundingText.join(' ');
                        }
                        
                        // Find which scene this is in
                        let sceneNumber = 1;
                        for (let s = 0; s < scenes.length; s++) {
                            if (scenes[s].lineNumber > i) break;
                            sceneNumber = scenes[s].number;
                        }
                        
                        introductions[cleaned] = {
                            name: cleaned,
                            firstScene: sceneNumber,
                            description: description.substring(0, 200)
                        };
                    }
                }
            }
            
            return introductions;
        }
        
        // AI Synopsis Generation
        async function generateAISynopsis(sceneIndex) {
            const scene = scenes[sceneIndex];
            const content = extractSceneContent(scene);
            
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Generating...';
            
            try {
                console.log('Starting AI synopsis generation...');
                
                const prompt = `Analyze this screenplay scene and provide:
1. A brief 1-2 sentence synopsis of what happens
2. ALL cast members in the scene - USE FULL NAMES when available

IMPORTANT CHARACTER NAMING RULES:
- If a character has a full name (e.g., "EMMA HART"), always use the FULL NAME
- If you see "Emma" or "EMMA" and context suggests it's the same person as "EMMA HART", use "EMMA HART"
- Use the MOST COMPLETE name form you can find in the scene
- Look for names in: dialogue headers, action lines, character descriptions

Scene heading: ${scene.heading}

Scene content:
${content}

Respond in JSON format:
{
  "synopsis": "brief description",
  "cast": ["EMMA HART", "SARAH CHEN"]
}

Examples:
- If you see "EMMA HART" anywhere in the script, always use "EMMA HART" (not just "EMMA")
- If you see "DR. WILSON" or "Dr. Wilson", use "DR. WILSON"
- Prefer full names over shortened versions

IMPORTANT: Respond ONLY with valid JSON. Do not include any text outside the JSON structure.`;

                const responseText = await callAI(prompt, 300);
                console.log('AI Response:', responseText);
                
                // Clean and parse response
                let cleanedResponse = responseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
                console.log('Cleaned response:', cleanedResponse);
                const result = JSON.parse(cleanedResponse);
                
                // Update scene synopsis
                scene.synopsis = result.synopsis;
                
                // Update cast
                if (!sceneBreakdowns[sceneIndex]) {
                    sceneBreakdowns[sceneIndex] = {};
                }
                if (!sceneBreakdowns[sceneIndex].cast) {
                    sceneBreakdowns[sceneIndex].cast = [];
                }
                
                result.cast.forEach(castMember => {
                    const normalizedName = normalizeCastName(castMember);
                    if (!normalizedName) return;

                    const existingCast = sceneBreakdowns[sceneIndex].cast || [];
                    const matchingMember = findMatchingCastMember(normalizedName, existingCast);

                    if (matchingMember) {
                        // Character already exists - use existing name
                        const finalName = matchingMember;

                        // Update to longer name if new name is more complete
                        const betterName = mergeCharacterNames(matchingMember, normalizedName);
                        if (betterName !== matchingMember) {
                            // Rename everywhere
                            renameCharacterEverywhere(matchingMember, betterName);
                        }

                        if (!castProfiles[finalName]) {
                            castProfiles[finalName] = {
                                name: finalName,
                                baseDescription: '',
                                scenes: []
                            };
                        }
                        if (!castProfiles[finalName].scenes.includes(scene.number)) {
                            castProfiles[finalName].scenes.push(scene.number);
                        }
                    } else {
                        // New character - check ALL existing cast globally for matches
                        const allExistingCast = new Set();
                        Object.values(sceneBreakdowns).forEach(breakdown => {
                            if (breakdown.cast) {
                                breakdown.cast.forEach(c => allExistingCast.add(c));
                            }
                        });

                        const globalMatch = findMatchingCastMember(normalizedName, Array.from(allExistingCast));

                        if (globalMatch) {
                            // Match found in other scenes - use that name
                            const finalName = globalMatch;

                            // Update to longer name if new name is more complete
                            const betterName = mergeCharacterNames(globalMatch, normalizedName);
                            if (betterName !== globalMatch) {
                                renameCharacterEverywhere(globalMatch, betterName);
                            }

                            if (!sceneBreakdowns[sceneIndex].cast.includes(finalName)) {
                                sceneBreakdowns[sceneIndex].cast.push(finalName);
                            }
                            if (!castProfiles[finalName].scenes.includes(scene.number)) {
                                castProfiles[finalName].scenes.push(scene.number);
                            }
                        } else {
                            // Truly new character
                            if (!sceneBreakdowns[sceneIndex].cast.includes(normalizedName)) {
                                sceneBreakdowns[sceneIndex].cast.push(normalizedName);
                            }

                            if (!castProfiles[normalizedName]) {
                                castProfiles[normalizedName] = {
                                    name: normalizedName,
                                    baseDescription: '',
                                    scenes: []
                                };
                            }
                            if (!castProfiles[normalizedName].scenes.includes(scene.number)) {
                                castProfiles[normalizedName].scenes.push(scene.number);
                            }
                        }
                    }
                });
                
                saveProject();
                renderSceneList();
                if (currentScene === sceneIndex) {
                    renderBreakdownPanel();
                    renderCastPanel();
                }

                // Refresh character tabs if new characters were added
                initializeCharacterTabs();

            } catch (error) {
                console.error('AI Synopsis Error:', error);
                alert(`Failed to generate synopsis:\n\n${error.message}\n\nCheck the browser console (F12) for more details.`);
            } finally {
                btn.disabled = false;
                btn.textContent = 'âœ¨ Generate AI Synopsis';
            }
        }
        
        // AI Element Detection
        async function detectAIElements(sceneIndex) {
            const scene = scenes[sceneIndex];
            const content = extractSceneContent(scene);

            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Detecting...';

            try {
                console.log('Starting AI element detection...');

                const prompt = `You are a professional script breakdown assistant. Analyze this scene and identify ALL elements needed for production planning.

âš ï¸ CRITICAL: Find CAST MEMBERS FIRST before any other elements.

Scene heading: ${scene.heading}

Scene content:
${content}

IDENTIFICATION PRIORITY:

ðŸŽ­ PRIORITY 1 - CAST MEMBERS (MOST IMPORTANT):
Find EVERY person mentioned in this scene by name:
- Character names in dialogue headers (ALL CAPS format)
- Character names in action lines (proper nouns)
- People with descriptions in parentheses: "GWEN LAWSON (30s, tired)"
- Any person referred to by name in the narrative

For cast members:
- Use the MOST COMPLETE name form (e.g., "GWEN LAWSON" not just "GWEN")
- If this appears to be a character introduction (first time with description), note it
- Capture the exact name as it appears
- Include the full sentence for context

ðŸ’„ PRIORITY 2 - MAKEUP DEPARTMENT ELEMENTS:
Only for character appearance/condition elements:

- hair: hairstyles, hair changes, hair conditions, wigs, beards
  Example: "disheveled hair", "tied back in bun", "beard trimmed"

- makeup: beauty makeup only (foundation, lipstick, eye makeup, stage makeup)
  Example: "natural makeup", "heavy stage makeup", "lipstick smudged"

- sfx: special effects makeup (wounds, blood, prosthetics, scars, bruises, dirt, grime)
  Example: "black eye", "bleeding wound", "covered in dirt"

- health: illness symptoms, complexion changes, fatigue indicators
  Example: "pale complexion", "dark circles under eyes", "feverish"

- injuries: cuts, broken bones, swelling, bandages
  Example: "broken arm in cast", "cut on forehead", "swollen eye"

- stunts: fights, falls, impacts that affect appearance
  Example: "thrown against wall", "punch to face"

- weather: weather effects on appearance
  Example: "rain-soaked", "windswept hair", "sunburned"

- wardrobe: costume damage, blood/dirt on clothes (NOT full costume descriptions)
  Example: "torn shirt", "blood-stained jacket", "muddy jeans"

- extras: background performers, crowds, non-speaking roles
  Example: "crowd of onlookers", "busy restaurant patrons", "pedestrians"

IMPORTANT RULES:
1. ALWAYS find cast members first
2. For each element, provide the exact short text snippet (2-5 words)
3. Include the full sentence as context
4. Assign elements to specific characters when possible
5. Mark if a cast member appears to be introduced in this scene

OUTPUT FORMAT (JSON only):
{
  "tags": [
    {
      "category": "cast",
      "text": "GWEN LAWSON",
      "context": "GWEN LAWSON (30s, exhausted) enters the taxi and sits heavily.",
      "character": "GWEN LAWSON",
      "isIntroduction": true
    },
    {
      "category": "cast",
      "text": "PETER",
      "context": "PETER coughs violently, covering his mouth.",
      "character": "PETER",
      "isIntroduction": false
    },
    {
      "category": "sfx",
      "text": "coughs violently",
      "context": "PETER coughs violently, covering his mouth.",
      "character": "PETER"
    },
    {
      "category": "hair",
      "text": "disheveled",
      "context": "Her hair is disheveled from the wind.",
      "character": "GWEN LAWSON"
    }
  ]
}

âš ï¸ RESPOND WITH ONLY VALID JSON. NO OTHER TEXT.`;

                const responseText = await callAI(prompt, 1000);
                console.log('Element detection response:', responseText);

                // Clean and parse response
                let cleanedResponse = responseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
                console.log('Cleaned element response:', cleanedResponse);
                const result = JSON.parse(cleanedResponse);

                // Create tags from AI results
                if (!scriptTags[sceneIndex]) {
                    scriptTags[sceneIndex] = [];
                }

                if (!sceneBreakdowns[sceneIndex]) {
                    sceneBreakdowns[sceneIndex] = {
                        cast: [],
                        hair: [],
                        makeup: [],
                        sfx: [],
                        health: [],
                        injuries: [],
                        stunts: [],
                        weather: [],
                        wardrobe: [],
                        extras: []
                    };
                }

                let tagsCreated = 0;

                if (result.tags && Array.isArray(result.tags)) {
                    result.tags.forEach(aiTag => {
                        // Validate character is actual cast before assigning
                        const isActualCast = sceneBreakdowns[sceneIndex].cast?.includes(aiTag.character);

                        // Special handling for CAST category
                        if (aiTag.category === 'cast') {
                            const castName = normalizeCastName(aiTag.text);

                            // Add to scene breakdown if not already there
                            if (!sceneBreakdowns[sceneIndex].cast) {
                                sceneBreakdowns[sceneIndex].cast = [];
                            }

                            // Check for existing match
                            const existingMatch = findMatchingCastMember(
                                castName,
                                sceneBreakdowns[sceneIndex].cast
                            );

                            const finalName = existingMatch || castName;

                            if (!sceneBreakdowns[sceneIndex].cast.includes(finalName)) {
                                sceneBreakdowns[sceneIndex].cast.push(finalName);
                            }

                            // Initialize cast profile if needed
                            if (!castProfiles[finalName]) {
                                castProfiles[finalName] = {
                                    name: finalName,
                                    baseDescription: aiTag.isIntroduction ? aiTag.context : '',
                                    scenes: []
                                };
                            }

                            if (!castProfiles[finalName].scenes.includes(scene.number)) {
                                castProfiles[finalName].scenes.push(scene.number);
                            }

                            // Create tag for highlighting
                            const tag = {
                                id: Date.now() + Math.random(),
                                sceneIndex: sceneIndex,
                                sceneNumber: scene.number,
                                category: 'cast',
                                selectedText: aiTag.text,
                                fullContext: aiTag.context,
                                character: finalName,
                                isIntroduction: aiTag.isIntroduction || false,
                                continuityType: 'oneoff',
                                continuityEventId: null,
                                elementId: `ai-tag-${Date.now()}-${Math.random()}`,
                                created: Date.now(),
                                aiGenerated: true
                            };

                            scriptTags[sceneIndex].push(tag);
                            tagsCreated++;

                        } else {
                            // Non-cast element - existing logic
                            const tag = {
                                id: Date.now() + Math.random(),
                                sceneIndex: sceneIndex,
                                sceneNumber: scene.number,
                                category: aiTag.category,
                                selectedText: aiTag.text,
                                fullContext: aiTag.context,
                                character: isActualCast ? aiTag.character : null,
                                continuityType: 'oneoff',
                                continuityEventId: null,
                                elementId: `ai-tag-${Date.now()}-${Math.random()}`,
                                created: Date.now(),
                                aiGenerated: true
                            };

                            scriptTags[sceneIndex].push(tag);

                            const categoryKey = aiTag.category;
                            if (sceneBreakdowns[sceneIndex][categoryKey]) {
                                if (!sceneBreakdowns[sceneIndex][categoryKey].includes(aiTag.text)) {
                                    sceneBreakdowns[sceneIndex][categoryKey].push(aiTag.text);
                                }
                            }

                            tagsCreated++;
                        }
                    });
                }

                console.log(`Created ${tagsCreated} tags from AI detection`);

                saveProject();

                // Re-render the breakdown panels
                if (currentScene === sceneIndex) {
                    renderBreakdownPanel();
                    renderCastPanel();
                    renderTagsPanel();
                }

                // Refresh character tabs if new characters were added
                initializeCharacterTabs();

                // CRITICAL: Apply highlights after a delay to ensure DOM is ready
                setTimeout(() => {
                    console.log('Applying highlights for scene:', sceneIndex);
                    const sceneTags = scriptTags[sceneIndex] || [];

                    sceneTags.forEach((tag, index) => {
                        console.log(`Highlighting tag ${index + 1}/${sceneTags.length}:`, tag.selectedText);
                        applyAITagHighlight(tag);
                    });

                    // Apply margin indicators after highlights
                    setTimeout(() => {
                        renderMarginIndicators();
                    }, 200);
                }, 500);

                console.log(`âœ“ AI detected ${tagsCreated} elements and created highlights`);

            } catch (error) {
                console.error('AI Detection Error:', error);
                alert(`Failed to detect elements:\n\n${error.message}\n\nCheck the browser console (F12) for more details.`);
            } finally {
                btn.disabled = false;
                btn.textContent = 'ðŸ” Detect Elements with AI';
            }
        }

        // Apply AI-generated tag highlights
        function applyAITagHighlight(tag) {
            console.log('Attempting to apply highlight for tag:', tag);

            // Wait for DOM to be ready
            setTimeout(() => {
                // Find the scene container
                const sceneId = `scene-${scenes[tag.sceneIndex].number}`;
                const sceneContainer = document.getElementById(sceneId);

                if (!sceneContainer) {
                    console.warn('Scene container not found:', sceneId);
                    return;
                }

                console.log('Found scene container:', sceneId);

                // Search through all text elements in this scene
                const textElements = sceneContainer.querySelectorAll('.script-action, .script-dialogue, .script-character, .script-parenthetical');

                let highlighted = false;

                for (let element of textElements) {
                    const text = element.textContent;

                    // Check if this element contains the tagged text
                    if (text.includes(tag.selectedText)) {
                        console.log('Found matching text in element:', element);

                        // Assign element ID if it doesn't have one
                        if (!element.id) {
                            element.id = `element-${Date.now()}-${Math.random()}`;
                        }
                        tag.elementId = element.id;

                        // Get current HTML
                        const innerHTML = element.innerHTML;

                        // Check if already highlighted
                        if (innerHTML.includes(`data-tag-id="${tag.id}"`)) {
                            console.log('Already highlighted, skipping');
                            return;
                        }

                        // Escape special regex characters in the selected text
                        const escapedText = tag.selectedText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

                        // Create regex that matches whole word/phrase
                        const regex = new RegExp(`(${escapedText})`, 'gi');

                        // ADD INTRODUCTION ATTRIBUTE FOR CAST TAGS
                        const introAttr = tag.category === 'cast' && tag.isIntroduction
                            ? ' data-introduction="true"'
                            : '';

                        // Replace with highlighted version
                        const highlightedHTML = innerHTML.replace(regex,
                            `<span class="tag-highlight" data-tag-id="${tag.id}" data-category="${tag.category}"${introAttr} data-character="${tag.character || ''}" onclick="handleTagClick(event, '${tag.id}')" oncontextmenu="showTagContextMenu(event, '${tag.id}'); return false;">$1</span>`
                        );

                        element.innerHTML = highlightedHTML;
                        console.log('âœ“ Applied highlight for:', tag.selectedText);
                        highlighted = true;
                        break;
                    }
                }

                if (!highlighted) {
                    console.warn('Could not find text to highlight:', tag.selectedText);
                }
            }, 100); // Small delay to ensure DOM is ready
        }
        
        // Handle clicking on highlighted tags
        function handleTagClick(event, tagId) {
            event.stopPropagation();

            // Find the tag
            let tag = null;
            for (let sceneIndex in scriptTags) {
                const found = scriptTags[sceneIndex].find(t => t.id.toString() === tagId || t.id === tagId);
                if (found) {
                    tag = found;
                    break;
                }
            }

            if (!tag) return;

            // If it's a cast member, open their character tab
            if (tag.category === 'cast' && tag.character) {
                switchCenterTab(`character-${tag.character}`);
            } else {
                // For other tags, show the tag popup with info
                showTagInfo(tag);
            }
        }

        // Show tag info in a tooltip
        function showTagInfo(tag) {
            const existing = document.getElementById('tagTooltip');
            if (existing) existing.remove();

            const tooltip = document.createElement('div');
            tooltip.id = 'tagTooltip';
            tooltip.className = 'tag-tooltip';
            tooltip.innerHTML = `
                <div class="tooltip-header">
                    <span class="tooltip-category">${tag.category.toUpperCase()}</span>
                    ${tag.character ? `<span class="tooltip-character">â†’ ${tag.character}</span>` : ''}
                </div>
                <div class="tooltip-text">${tag.selectedText}</div>
                <div class="tooltip-context">${tag.fullContext}</div>
                <div class="tooltip-actions">
                    <button onclick="document.getElementById('tagTooltip').remove()">Close</button>
                </div>
            `;

            document.body.appendChild(tooltip);

            // Position near cursor
            const highlight = document.querySelector(`[data-tag-id="${tag.id}"]`);
            if (highlight) {
                const rect = highlight.getBoundingClientRect();
                tooltip.style.position = 'fixed';
                tooltip.style.left = rect.left + 'px';
                tooltip.style.top = (rect.bottom + 10) + 'px';
                tooltip.style.zIndex = '3000';
            }

            // Auto-close after 5 seconds
            setTimeout(() => {
                if (document.getElementById('tagTooltip')) {
                    document.getElementById('tagTooltip').remove();
                }
            }, 5000);
        }

        // Extract scene content
        function extractSceneContent(scene) {
            const lines = scriptText.split('\n');
            const startLine = scene.lineNumber;
            let endLine = lines.length;

            const sceneIndex = scenes.indexOf(scene);
            if (sceneIndex < scenes.length - 1) {
                endLine = scenes[sceneIndex + 1].lineNumber;
            }

            return lines.slice(startLine, endLine).join('\n');
        }
        
        // Switch tabs (Legacy function - now simplified since we removed Cast and Tags tabs)
        function switchTab(tab) {
            // Only breakdown tab remains - this function is kept for backward compatibility
            activeTab = 'breakdown';

            // Ensure breakdown panel is always active
            const breakdownPanel = document.getElementById('breakdownPanel');
            if (breakdownPanel) {
                breakdownPanel.classList.add('active');
            }
        }
        
        // Render scene list
        function renderSceneList() {
            const container = document.getElementById('sceneList');
            
            if (scenes.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-icon">ðŸŽ¬</div><div class="empty-desc">No scenes detected</div></div>';
                return;
            }
            
            container.innerHTML = scenes.map((scene, index) => {
                const sceneType = getSceneType(scene.heading);
                const sceneTypeLabel = getSceneTypeLabel(sceneType);
                const breakdown = sceneBreakdowns[index] || {};
                const cast = breakdown.cast || [];
                const isActive = currentScene === index;
                
                // Count elements
                let elementCounts = [];
                categories.forEach(cat => {
                    const items = breakdown[cat.id] || [];
                    if (items.length > 0 && cat.id !== 'cast') {
                        elementCounts.push(`${cat.name}: ${items.length}`);
                    }
                });
                
                return `
                    <div class="scene-item ${sceneType} ${isActive ? 'active' : ''}" onclick="selectScene(${index})">
                        <div class="scene-header">
                            <div class="scene-number">${scene.number}</div>
                            <div class="scene-info">
                                <div class="scene-heading">${scene.heading}</div>
                                <div class="scene-meta">
                                    <span class="scene-type-indicator ${sceneType}">${sceneTypeLabel}</span>
                                </div>
                            </div>
                        </div>
                        
                        ${isActive ? `
                            <div class="scene-expanded">
                                <!-- READ-ONLY METADATA OVERVIEW -->
                                <div class="scene-metadata-overview">
                                    ${scene.storyDay ? `
                                        <div class="metadata-pill">
                                            <span class="metadata-pill-icon">ðŸ“…</span>
                                            <span class="metadata-pill-text">${scene.storyDay}</span>
                                        </div>
                                    ` : ''}
                                    ${scene.timeOfDay ? `
                                        <div class="metadata-pill">
                                            <span class="metadata-pill-icon">ðŸ•</span>
                                            <span class="metadata-pill-text">${scene.timeOfDay}</span>
                                        </div>
                                    ` : ''}
                                    ${scene.location ? `
                                        <div class="metadata-pill">
                                            <span class="metadata-pill-icon">ðŸ“</span>
                                            <span class="metadata-pill-text">${scene.location}</span>
                                        </div>
                                    ` : ''}
                                </div>

                                ${scene.synopsis ? `<div class="scene-synopsis">${scene.synopsis}</div>` : `<div class="scene-synopsis placeholder">No synopsis yet</div>`}
                                
                                ${cast.length > 0 ? `
                                    <div class="scene-cast-list">
                                        ${cast.map(c => `<div class="cast-chip">${c}</div>`).join('')}
                                    </div>
                                ` : ''}
                                
                                ${elementCounts.length > 0 ? `
                                    <div class="element-summary">
                                        ${elementCounts.slice(0, 3).map(e => `<div class="element-count">${e}</div>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // Select scene
        function selectSceneFromScript(index) {
            // Save current scene data first
            if (currentScene !== null && currentScene !== index) {
                autoSaveCurrentScene();
            }

            // Select the new scene
            selectScene(index);
        }

        function autoSaveCurrentScene() {
            if (currentScene === null) return;

            console.log('Auto-saving scene', currentScene);

            // Save the project
            saveProject();
        }

        function navigateToScene(sceneIndex) {
            if (sceneIndex < 0 || sceneIndex >= scenes.length) return;

            // Auto-save current scene before switching
            if (currentScene !== null) {
                saveProject();
            }

            // Select new scene
            selectScene(sceneIndex);

            // Scroll to scene in script (if on script tab)
            if (activeCenterTab === 'script') {
                setTimeout(() => {
                    const sceneEl = document.getElementById(`scene-${scenes[sceneIndex].number}`);
                    if (sceneEl) {
                        sceneEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
        }

        function selectScene(index) {
            // Auto-save previous scene before switching
            if (currentScene !== null && currentScene !== index) {
                console.log('Auto-saving scene', currentScene, 'before switching to', index);
                saveProject();
            }

            currentScene = index;
            renderSceneList();
            renderBreakdownPanel();
            renderCastPanel();

            const sceneEl = document.getElementById(`scene-${scenes[index].number}`);
            if (sceneEl) {
                sceneEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        // Render breakdown panel
        function renderBreakdownPanel() {
            const container = document.getElementById('breakdownPanel');

            if (currentScene === null) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ðŸ“‹</div>
                        <div class="empty-title">Select a Scene</div>
                        <div class="empty-desc">Choose a scene to view and edit its breakdown</div>
                    </div>
                `;
                return;
            }

            const scene = scenes[currentScene];
            const breakdown = sceneBreakdowns[currentScene] || {};

            // Get cast list
            const cast = breakdown.cast || [];

            // Count tagged elements
            const sceneTags = scriptTags[currentScene] || [];
            const tagCounts = {};
            sceneTags.forEach(tag => {
                if (!tagCounts[tag.category]) tagCounts[tag.category] = 0;
                tagCounts[tag.category]++;
            });

            // Scene navigation data
            const hasPrevious = currentScene > 0;
            const hasNext = currentScene < scenes.length - 1;
            const previousScene = hasPrevious ? scenes[currentScene - 1] : null;
            const nextScene = hasNext ? scenes[currentScene + 1] : null;

            let html = `
                <!-- SCENE NAVIGATION BAR - STICKY AT TOP -->
                <div class="breakdown-scene-nav-sticky">
                    <button class="scene-nav-btn-compact ${!hasPrevious ? 'disabled' : ''}"
                            onclick="navigateToScene(${currentScene - 1})"
                            ${!hasPrevious ? 'disabled' : ''}>
                        â† ${hasPrevious ? `Scene ${previousScene.number}` : ''}
                    </button>
                    <div class="scene-nav-current-compact">
                        SCENE ${scene.number}
                    </div>
                    <button class="scene-nav-btn-compact ${!hasNext ? 'disabled' : ''}"
                            onclick="navigateToScene(${currentScene + 1})"
                            ${!hasNext ? 'disabled' : ''}>
                        ${hasNext ? `Scene ${nextScene.number}` : ''} â†’
                    </button>
                </div>

                <!-- SYNOPSIS SECTION -->
                <div class="breakdown-synopsis-section">
                    <div class="section-header">
                        <span>Synopsis</span>
                        <button class="ai-btn-compact" onclick="generateAISynopsis(${currentScene})" title="Generate synopsis with AI">
                            âœ¨ Generate
                        </button>
                    </div>
                    <div class="synopsis-display">${scene.synopsis || 'Click Generate to create synopsis...'}</div>
                </div>

                <!-- SCENE INFORMATION - COLLAPSIBLE -->
                <div class="scene-info-section" id="sceneInfoSection">
                    <div class="scene-info-header" onclick="toggleSceneInfo()">
                        <span class="scene-info-title">Scene Info ${(scene.storyDay && scene.timeOfDay && scene.intExt && scene.location) ? 'âœ“' : 'âš '}</span>
                        <button class="scene-info-toggle">â–¶</button>
                    </div>
                    <div class="scene-info-content">
                        <div class="scene-info-compact">
                            <div class="info-row">
                                <div class="info-field">
                                    <label>Story Day</label>
                                    <input type="text"
                                           value="${scene.storyDay || ''}"
                                           placeholder="Day 1..."
                                           onchange="updateSceneMetadata(${currentScene}, 'storyDay', this.value)">
                                </div>
                                <div class="info-field">
                                    <label>Time</label>
                                    <select onchange="updateSceneMetadata(${currentScene}, 'timeOfDay', this.value)">
                                        <option value="">-- Time --</option>
                                        <option value="Day" ${(scene.timeOfDay || detectTimeOfDay(scene.heading)) === 'Day' ? 'selected' : ''}>Day</option>
                                        <option value="Morning" ${(scene.timeOfDay || detectTimeOfDay(scene.heading)) === 'Morning' ? 'selected' : ''}>Morning</option>
                                        <option value="Afternoon" ${(scene.timeOfDay || detectTimeOfDay(scene.heading)) === 'Afternoon' ? 'selected' : ''}>Afternoon</option>
                                        <option value="Evening" ${(scene.timeOfDay || detectTimeOfDay(scene.heading)) === 'Evening' ? 'selected' : ''}>Evening</option>
                                        <option value="Night" ${(scene.timeOfDay || detectTimeOfDay(scene.heading)) === 'Night' ? 'selected' : ''}>Night</option>
                                    </select>
                                </div>
                                <div class="info-field">
                                    <label>INT/EXT</label>
                                    <select onchange="updateSceneMetadata(${currentScene}, 'intExt', this.value)">
                                        <option value="">-- Type --</option>
                                        <option value="INT" ${scene.intExt === 'INT' ? 'selected' : ''}>INT</option>
                                        <option value="EXT" ${scene.intExt === 'EXT' ? 'selected' : ''}>EXT</option>
                                        <option value="INT/EXT" ${scene.intExt === 'INT/EXT' ? 'selected' : ''}>INT/EXT</option>
                                    </select>
                                </div>
                            </div>
                            <div class="info-row">
                                <div class="info-field full-width">
                                    <label>Location</label>
                                    <input type="text"
                                           value="${scene.location || extractLocation(scene.heading) || ''}"
                                           placeholder="FERRY"
                                           onchange="updateSceneMetadata(${currentScene}, 'location', this.value)">
                                </div>
                            </div>
                            <div class="ai-detect-row">
                                <button class="ai-btn-compact" onclick="detectAIElements(${currentScene})" title="Auto-detect cast & elements">
                                    ðŸ” Auto-Detect Elements
                                </button>
                                <div class="ai-status" id="aiStatus"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TAGGED ELEMENTS PILLS (only non-empty) -->
                ${Object.keys(tagCounts).length > 0 ? `
                    <div class="tagged-pills">
                        ${Object.entries(tagCounts).map(([cat, count]) => {
                            const category = categories.find(c => c.id === cat);
                            return `<div class="tagged-pill" onclick="jumpToCategory('${cat}')">${category?.icon || 'ðŸ“Œ'} ${category?.name || cat}: ${count}</div>`;
                        }).join('')}
                    </div>
                ` : ''}

                <!-- CAST IN THIS SCENE - Enhanced with Expandable Cards -->
                ${cast.length > 0 ? `
                    <div style="margin: 24px 0;">
                        <div class="section-title" style="margin-bottom: 16px;">
                            <span class="section-icon" style="background: rgba(251, 191, 36, 0.5);"></span>
                            CAST (${cast.length})
                        </div>

                        ${cast.map(castMember => {
                            const profile = castProfiles[castMember] || {};
                            const state = characterStates[currentScene]?.[castMember] || {};
                            const activeEvents = getActiveEventsForScene(castMember, currentScene);

                            // Create inline preview for collapsed state
                            const hairPreview = (state.hair || '').substring(0, 40);
                            const makeupPreview = (state.makeup || '').substring(0, 40);
                            const sfxPreview = (state.sfx || '').substring(0, 40);
                            const previewParts = [];
                            if (hairPreview) previewParts.push(`ðŸ’‡ ${hairPreview}${state.hair && state.hair.length > 40 ? '...' : ''}`);
                            if (makeupPreview) previewParts.push(`ðŸ’„ ${makeupPreview}${state.makeup && state.makeup.length > 40 ? '...' : ''}`);
                            if (sfxPreview) previewParts.push(`ðŸ©¸ ${sfxPreview}${state.sfx && state.sfx.length > 40 ? '...' : ''}`);
                            const inlinePreview = previewParts.length > 0 ? previewParts.join(' â€¢ ') : '';

                            return `
                                <div class="cast-member-card" id="castCard${castMember.replace(/\s/g, '')}">
                                    <div class="cast-member-header" onclick="toggleCastCard('${castMember.replace(/\s/g, '')}')">
                                        <span class="cast-member-name">${castMember}</span>
                                        <div class="header-actions">
                                            <button class="ai-mini-btn" onclick="event.stopPropagation(); aiFillCharacterFields('${castMember}')">
                                                âœ¨ AI Fill
                                            </button>
                                            <span class="cast-member-toggle"></span>
                                        </div>
                                    </div>

                                    ${inlinePreview ? `<div class="cast-member-preview">${inlinePreview}</div>` : ''}

                                    <div class="cast-member-body">
                                        <div class="cast-member-base">
                                            Base: ${profile.baseDescription || 'No base description set'}
                                        </div>

                                        ${activeEvents.length > 0 ? `
                                            <div class="active-events-section">
                                                <div class="active-events-title">âš¡ Active Events</div>
                                                ${activeEvents.map(event => {
                                                    const progress = calculateEventProgress(event, currentScene);
                                                    const stage = getEventStageLabel(progress);
                                                    return `
                                                        <div class="event-item">
                                                            <div class="event-name">â€¢ ${event.description} (Sc ${event.startScene}-${event.endScene})</div>
                                                            <div class="event-timeline-info">
                                                                ${sceneTimeline[currentScene]?.label || 'Scene ' + scenes[currentScene].number}: ${stage.label} stage
                                                            </div>
                                                            <div class="continuity-progress">
                                                                <div class="progress-bar">
                                                                    <div class="progress-fill" style="width: ${progress}%;"></div>
                                                                </div>
                                                                <div class="progress-label">${progress}% healed</div>
                                                            </div>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}

                                        <div class="department-fields">
                                            <div class="department-field">
                                                <label class="department-label">Hair</label>
                                                <input type="text"
                                                       class="department-input"
                                                       value="${state.hair || ''}"
                                                       placeholder="Hairstyle, condition, changes..."
                                                       oninput="updateCharacterField('${castMember}', 'hair', this.value)">
                                            </div>

                                            <div class="department-field">
                                                <label class="department-label">Makeup</label>
                                                <input type="text"
                                                       class="department-input"
                                                       value="${state.makeup || ''}"
                                                       placeholder="Makeup look, details..."
                                                       oninput="updateCharacterField('${castMember}', 'makeup', this.value)">
                                            </div>

                                            <div class="department-field">
                                                <label class="department-label">SFX</label>
                                                <input type="text"
                                                       class="department-input"
                                                       value="${state.sfx || ''}"
                                                       placeholder="Injuries, wounds, prosthetics..."
                                                       oninput="updateCharacterField('${castMember}', 'sfx', this.value)">
                                            </div>

                                            <div class="department-field">
                                                <label class="department-label">Wardrobe</label>
                                                <input type="text"
                                                       class="department-input"
                                                       value="${state.wardrobe || ''}"
                                                       placeholder="Costume description, accessories..."
                                                       oninput="updateCharacterField('${castMember}', 'wardrobe', this.value)">
                                            </div>

                                            <div class="department-field">
                                                <label class="department-label">Notes</label>
                                                <input type="text"
                                                       class="department-input"
                                                       value="${state.notes || ''}"
                                                       placeholder="Additional notes..."
                                                       oninput="updateCharacterField('${castMember}', 'notes', this.value)">
                                            </div>
                                        </div>

                                        <div class="cast-member-actions">
                                            <button class="view-timeline-btn" onclick="openCastProfile('${castMember}')">
                                                ðŸ“Š View ${castMember}'s Timeline
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}

                        <button class="add-element-btn" style="width: 100%; margin-top: 12px;" onclick="openAddElement('cast')">
                            + Add Cast Member to Scene
                        </button>
                    </div>
                ` : `
                    <div style="margin: 24px 0;">
                        <div class="empty-state-small">
                            <div class="empty-icon-small">ðŸ‘¥</div>
                            <div class="empty-text-small">No cast members in this scene. Use AI detection or add manually.</div>
                        </div>
                        <button class="add-element-btn" style="width: 100%; margin-top: 12px;" onclick="openAddElement('cast')">
                            + Add Cast Member to Scene
                        </button>
                    </div>
                `}
            `;

            // Render all category sections EXCEPT cast (handled separately above)
            // Only render categories that have elements (hide empty categories)
            categories.filter(cat => cat.id !== 'cast').forEach(cat => {
                const elements = breakdown[cat.id] || [];

                // ONLY render if category has elements
                if (elements.length > 0) {
                    const isExpanded = false; // Collapsed by default

                    html += `
                        <div class="breakdown-section has-content ${isExpanded ? 'expanded' : ''}"
                             id="category-${cat.id}"
                             data-category="${cat.id}">
                            <div class="section-header" onclick="toggleCategory('${cat.id}')">
                                <div class="section-header-left">
                                    <span class="section-icon" style="background: ${cat.color}"></span>
                                    <span class="section-title">${cat.icon} ${cat.name}</span>
                                    <span class="category-count has-items">${elements.length}</span>
                                </div>
                                <button class="category-toggle" onclick="event.stopPropagation();">${isExpanded ? 'â–¼' : 'â–¶'}</button>
                            </div>
                            <div class="section-content">
                                <div class="element-list">
                                    ${elements.map(el => `
                                        <div class="element-item">
                                            <div class="element-text">${el}</div>
                                            <button class="element-remove" onclick="removeElement('${cat.id}', '${el.replace(/'/g, "\\'")}')">Ã—</button>
                                        </div>
                                    `).join('')}
                                </div>
                                <button class="add-element-btn" style="width: 100%; margin-top: 8px;" onclick="openAddElement('${cat.id}')">+ Add ${cat.name}</button>
                            </div>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
        }
        
        // Render cast panel (DEPRECATED - functionality moved to Scene Breakdown panel)
        function renderCastPanel() {
            // No-op: Cast functionality is now integrated into the Scene Breakdown panel
            // This function is kept for backward compatibility with existing code that calls it
        }
        
        // Add element
        function openAddElement(categoryId) {
            currentElementCategory = categoryId;
            document.getElementById('addElementModal').classList.add('active');
            document.getElementById('elementInput').value = '';
            document.getElementById('elementInput').focus();
        }
        
        function closeAddElementModal() {
            document.getElementById('addElementModal').classList.remove('active');
            currentElementCategory = null;
        }
        
        function confirmAddElement() {
            const value = document.getElementById('elementInput').value.trim();
            if (!value || !currentElementCategory) return;
            
            if (!sceneBreakdowns[currentScene]) {
                sceneBreakdowns[currentScene] = {};
            }
            if (!sceneBreakdowns[currentScene][currentElementCategory]) {
                sceneBreakdowns[currentScene][currentElementCategory] = [];
            }
            
            if (currentElementCategory === 'cast') {
                // Normalize name
                const normalizedName = normalizeCastName(value);

                // Check for duplicates
                const existingCast = sceneBreakdowns[currentScene].cast || [];
                const matchingMember = findMatchingCastMember(normalizedName, existingCast);

                if (matchingMember) {
                    alert(`This character already exists as "${matchingMember}". Use that name instead.`);
                    return;
                }

                if (!sceneBreakdowns[currentScene][currentElementCategory].includes(normalizedName)) {
                    sceneBreakdowns[currentScene][currentElementCategory].push(normalizedName);
                }

                if (!castProfiles[normalizedName]) {
                    castProfiles[normalizedName] = {
                        name: normalizedName,
                        baseDescription: '',
                        scenes: []
                    };
                }
                if (!castProfiles[normalizedName].scenes.includes(scenes[currentScene].number)) {
                    castProfiles[normalizedName].scenes.push(scenes[currentScene].number);
                }

                saveProject();
                renderBreakdownPanel();
                renderCastPanel();
                renderSceneList();
                initializeCharacterTabs();
            } else {
                if (!sceneBreakdowns[currentScene][currentElementCategory].includes(value)) {
                    sceneBreakdowns[currentScene][currentElementCategory].push(value);

                    saveProject();
                    renderBreakdownPanel();
                    renderCastPanel();
                    renderSceneList();
                }
            }

            closeAddElementModal();
        }
        
        // Remove element
        function removeElement(categoryId, element) {
            if (!sceneBreakdowns[currentScene] || !sceneBreakdowns[currentScene][categoryId]) return;
            
            sceneBreakdowns[currentScene][categoryId] = sceneBreakdowns[currentScene][categoryId].filter(e => e !== element);
            
            if (categoryId === 'cast' && castProfiles[element]) {
                castProfiles[element].scenes = castProfiles[element].scenes.filter(s => s !== scenes[currentScene].number);
            }
            
            saveProject();
            renderBreakdownPanel();
            renderCastPanel();
            renderSceneList();
        }
        
        // Add tag
        function openAddTag(castMember) {
            currentTagCharacter = castMember;
            document.getElementById('addTagTitle').textContent = `Add Tag for ${castMember}`;
            document.getElementById('addTagModal').classList.add('active');
            document.getElementById('tagInput').value = '';
            document.getElementById('tagIsWound').checked = false;
            document.getElementById('tagInput').focus();
        }
        
        function closeAddTagModal() {
            document.getElementById('addTagModal').classList.remove('active');
            currentTagCharacter = null;
        }
        
        function confirmAddTag() {
            const text = document.getElementById('tagInput').value.trim();
            const isWound = document.getElementById('tagIsWound').checked;
            if (!text || !currentTagCharacter) return;
            
            if (!characterStates[currentScene]) {
                characterStates[currentScene] = {};
            }
            if (!characterStates[currentScene][currentTagCharacter]) {
                characterStates[currentScene][currentTagCharacter] = { tags: [] };
            }
            if (!characterStates[currentScene][currentTagCharacter].tags) {
                characterStates[currentScene][currentTagCharacter].tags = [];
            }
            
            const exists = characterStates[currentScene][currentTagCharacter].tags.some(t => t.text === text);
            if (!exists) {
                characterStates[currentScene][currentTagCharacter].tags.push({ text, isWound });
                saveProject();
                renderCastPanel();
            }
            
            closeAddTagModal();
        }
        
        // Remove tag
        function removeTag(castMember, tagText) {
            if (!characterStates[currentScene] || !characterStates[currentScene][castMember]) return;
            
            characterStates[currentScene][castMember].tags = 
                characterStates[currentScene][castMember].tags.filter(t => t.text !== tagText);
            
            saveProject();
            renderCastPanel();
        }
        
        // Continuity Events
        function openContinuityModal(character) {
            currentEventCharacter = character;
            currentEditingEvent = null;
            
            document.getElementById('continuityModalTitle').textContent = `Add Continuity Event - ${character}`;
            document.getElementById('eventType').value = 'wound';
            document.getElementById('eventDescription').value = '';
            document.getElementById('eventStartDay').value = '';
            document.getElementById('eventEndDay').value = '';
            
            // Populate scene dropdowns
            const startSelect = document.getElementById('eventStartScene');
            const endSelect = document.getElementById('eventEndScene');
            startSelect.innerHTML = '';
            endSelect.innerHTML = '';
            
            scenes.forEach((scene, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Scene ${scene.number}: ${scene.heading.substring(0, 40)}...`;
                startSelect.appendChild(option);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = `Scene ${scene.number}: ${scene.heading.substring(0, 40)}...`;
                endSelect.appendChild(option2);
            });
            
            // Add "Ongoing" option to end
            const ongoingOption = document.createElement('option');
            ongoingOption.value = 'ongoing';
            ongoingOption.textContent = 'Ongoing (no end)';
            endSelect.appendChild(ongoingOption);
            
            // Set defaults
            if (currentScene !== null) {
                startSelect.value = currentScene;
                endSelect.value = Math.min(currentScene + 10, scenes.length - 1);
            }
            
            // Clear progression
            document.getElementById('progressionList').innerHTML = '<div style="color: var(--text-muted); font-size: 0.8125em; text-align: center; padding: 20px;">Click "AI Generate Progression" to get suggested stages, or the event will apply uniformly across all scenes.</div>';
            
            document.getElementById('continuityModal').classList.add('active');
        }
        
        function closeContinuityModal() {
            document.getElementById('continuityModal').classList.remove('active');
            currentEventCharacter = null;
            currentEditingEvent = null;
        }
        
        async function generateProgression() {
            const type = document.getElementById('eventType').value;
            const description = document.getElementById('eventDescription').value.trim();
            const startScene = parseInt(document.getElementById('eventStartScene').value);
            const endSceneVal = document.getElementById('eventEndScene').value;
            const endScene = endSceneVal === 'ongoing' ? null : parseInt(endSceneVal);
            const startDay = document.getElementById('eventStartDay').value.trim();
            const endDay = document.getElementById('eventEndDay').value.trim();
            
            if (!description) {
                alert('Please enter a description first');
                return;
            }
            
            const btn = document.getElementById('aiProgressionBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Generating...';
            
            try {
                console.log('Starting AI progression generation...');
                let timeContext = '';
                if (startDay && endDay) {
                    timeContext = `The event starts at ${startDay} and ends at ${endDay}.`;
                } else if (endScene !== null) {
                    const sceneDiff = endScene - startScene + 1;
                    timeContext = `The event spans ${sceneDiff} scenes.`;
                }
                
                const typeNames = {
                    'wound': 'wound/injury',
                    'illness': 'illness',
                    'aging': 'aging progression',
                    'deaging': 'de-aging effect',
                    'pregnancy': 'pregnancy progression',
                    'dirt': 'dirt/grime accumulation or removal',
                    'costume': 'costume damage progression',
                    'hair': 'hair change/growth',
                    'other': 'continuity change'
                };
                
                console.log('Requesting progression for:', description, 'Type:', type);
                
                const prompt = `You are a film production continuity expert. Generate realistic progression stages for a character's ${typeNames[type]}.

Description: ${description}
${timeContext}

Provide 3-5 progression stages showing how this ${typeNames[type]} would realistically change over time. Consider:
- For wounds: healing timeline (swelling, bruising colors, fading)
- For illness: symptom progression or recovery
- For aging: gradual changes in appearance
- For pregnancy: belly size, posture changes
- For dirt/grime: accumulation or cleaning
- For costume damage: wear and tear progression
- For hair: growth, cutting, styling changes

Respond ONLY with valid JSON in this format:
{
  "stages": [
    {
      "label": "Stage 1 (Days 1-3)" or "Initial" or similar,
      "description": "Detailed makeup/wardrobe notes for this stage"
    }
  ]
}

Make the descriptions specific and actionable for makeup/wardrobe departments.`;

                const responseText = await callAI(prompt, 800);
                console.log('Progression response:', responseText);
                
                // Clean and parse response
                let cleanedResponse = responseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
                console.log('Cleaned progression response:', cleanedResponse);
                const result = JSON.parse(cleanedResponse);
                
                // Display progression stages
                const listEl = document.getElementById('progressionList');
                listEl.innerHTML = result.stages.map(stage => `
                    <div class="progression-stage">
                        <div class="progression-stage-label">${stage.label}</div>
                        <div class="progression-stage-note">${stage.description}</div>
                    </div>
                `).join('');
                
                // Store for saving - update existing event or create new
                if (currentEditingEvent) {
                    currentEditingEvent.progression = result.stages;
                } else {
                    currentEditingEvent = { progression: result.stages };
                }
                
            } catch (error) {
                console.error('AI Progression Error:', error);
                alert(`Failed to generate progression:\n\n${error.message}\n\nCheck the browser console (F12) for more details.`);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'âœ¨ AI Generate Progression';
            }
        }
        
        function saveContinuityEvent() {
            const type = document.getElementById('eventType').value;
            const description = document.getElementById('eventDescription').value.trim();
            const startScene = parseInt(document.getElementById('eventStartScene').value);
            const endSceneVal = document.getElementById('eventEndScene').value;
            const endScene = endSceneVal === 'ongoing' ? null : parseInt(endSceneVal);
            const startDay = document.getElementById('eventStartDay').value.trim();
            const endDay = document.getElementById('eventEndDay').value.trim();
            
            if (!description) {
                alert('Please enter a description');
                return;
            }
            
            if (!continuityEvents[currentEventCharacter]) {
                continuityEvents[currentEventCharacter] = [];
            }
            
            // If editing existing event, update it
            if (currentEditingEvent && currentEditingEvent.id) {
                const existingIndex = continuityEvents[currentEventCharacter].findIndex(e => e.id === currentEditingEvent.id);
                if (existingIndex !== -1) {
                    continuityEvents[currentEventCharacter][existingIndex] = {
                        id: currentEditingEvent.id,
                        type: type,
                        description: description,
                        startScene: startScene,
                        endScene: endScene,
                        startDay: startDay,
                        endDay: endDay,
                        progression: currentEditingEvent.progression || []
                    };
                }
            } else {
                // Create new event
                const event = {
                    id: Date.now(),
                    type: type,
                    description: description,
                    startScene: startScene,
                    endScene: endScene,
                    startDay: startDay,
                    endDay: endDay,
                    progression: currentEditingEvent ? currentEditingEvent.progression : []
                };
                
                continuityEvents[currentEventCharacter].push(event);
            }
            
            saveProject();
            renderCastPanel();
            closeContinuityModal();
        }
        
        function getActiveEvents(character, sceneIndex) {
            if (!continuityEvents[character]) return [];
            
            return continuityEvents[character].filter(event => {
                const afterStart = sceneIndex >= event.startScene;
                const beforeEnd = event.endScene === null || sceneIndex <= event.endScene;
                return afterStart && beforeEnd;
            });
        }
        
        function getCurrentStage(event, sceneIndex) {
            if (!event.progression || event.progression.length === 0) {
                return event.description;
            }
            
            // Calculate position in timeline
            const totalScenes = event.endScene !== null ? 
                (event.endScene - event.startScene + 1) : 
                (scenes.length - event.startScene);
            const currentPosition = sceneIndex - event.startScene;
            const percentage = currentPosition / totalScenes;
            
            // Find appropriate stage
            const stageIndex = Math.min(
                Math.floor(percentage * event.progression.length),
                event.progression.length - 1
            );
            
            return event.progression[stageIndex].description;
        }
        
        function editContinuityEvent(character, eventId) {
            const event = continuityEvents[character].find(e => e.id === eventId);
            if (!event) return;
            
            currentEventCharacter = character;
            currentEditingEvent = event;
            
            document.getElementById('continuityModalTitle').textContent = `Edit Continuity Event - ${character}`;
            
            // Populate scene dropdowns first
            const startSelect = document.getElementById('eventStartScene');
            const endSelect = document.getElementById('eventEndScene');
            startSelect.innerHTML = '';
            endSelect.innerHTML = '';
            
            scenes.forEach((scene, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Scene ${scene.number}: ${scene.heading.substring(0, 40)}...`;
                startSelect.appendChild(option);
                
                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = `Scene ${scene.number}: ${scene.heading.substring(0, 40)}...`;
                endSelect.appendChild(option2);
            });
            
            const ongoingOption = document.createElement('option');
            ongoingOption.value = 'ongoing';
            ongoingOption.textContent = 'Ongoing (no end)';
            endSelect.appendChild(ongoingOption);
            
            // Now set values
            document.getElementById('eventType').value = event.type;
            document.getElementById('eventDescription').value = event.description;
            document.getElementById('eventStartScene').value = event.startScene;
            document.getElementById('eventEndScene').value = event.endScene === null ? 'ongoing' : event.endScene;
            document.getElementById('eventStartDay').value = event.startDay || '';
            document.getElementById('eventEndDay').value = event.endDay || '';
            
            // Show progression
            const listEl = document.getElementById('progressionList');
            if (event.progression && event.progression.length > 0) {
                listEl.innerHTML = event.progression.map(stage => `
                    <div class="progression-stage">
                        <div class="progression-stage-label">${stage.label}</div>
                        <div class="progression-stage-note">${stage.description}</div>
                    </div>
                `).join('');
            } else {
                listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 0.8125em; text-align: center; padding: 20px;">No progression stages defined.</div>';
            }
            
            document.getElementById('continuityModal').classList.add('active');
        }
        
        function deleteContinuityEvent(character, eventId) {
            if (!confirm('Delete this continuity event?')) return;

            continuityEvents[character] = continuityEvents[character].filter(e => e.id !== eventId);

            saveProject();
            renderCastPanel();
        }

        // ========== NEW: Story Day Aggregation & Visual Timeline Functions ==========

        // Get all unique story days for a character
        function getStoryDaysForCharacter(character) {
            const storyDays = new Map();

            scenes.forEach((scene, index) => {
                const breakdown = sceneBreakdowns[index] || {};
                const timeline = sceneTimeline[index] || {};

                if (breakdown.cast && breakdown.cast.includes(character)) {
                    const dayLabel = timeline.label || `Scene ${scene.number}`;
                    const storyDay = timeline.day || index + 1;
                    const timeOfDay = timeline.time || 'Unknown';

                    if (!storyDays.has(dayLabel)) {
                        storyDays.set(dayLabel, {
                            label: dayLabel,
                            day: storyDay,
                            time: timeOfDay,
                            scenes: []
                        });
                    }

                    storyDays.get(dayLabel).scenes.push({ scene, index, breakdown });
                }
            });

            return Array.from(storyDays.values());
        }

        // Aggregate look data for a story day
        function aggregateStoryDay(character, storyDayData) {
            const { scenes: dayScenes } = storyDayData;

            // Find the most detailed entry for each department
            const aggregated = {
                hair: '',
                makeup: '',
                sfx: '',
                wardrobe: '',
                notes: ''
            };

            dayScenes.forEach(({ index }) => {
                const state = characterStates[index]?.[character] || {};
                if (state.hair && state.hair.length > aggregated.hair.length) {
                    aggregated.hair = state.hair;
                }
                if (state.makeup && state.makeup.length > aggregated.makeup.length) {
                    aggregated.makeup = state.makeup;
                }
                if (state.sfx && state.sfx.length > aggregated.sfx.length) {
                    aggregated.sfx = state.sfx;
                }
                if (state.wardrobe && state.wardrobe.length > aggregated.wardrobe.length) {
                    aggregated.wardrobe = state.wardrobe;
                }
                if (state.notes && state.notes.length > aggregated.notes.length) {
                    aggregated.notes = state.notes;
                }
            });

            return aggregated;
        }

        // Get active continuity events for a specific story day/scene index
        function getActiveEventsForScene(character, sceneIndex) {
            if (!continuityEvents[character]) return [];

            return continuityEvents[character].filter(event => {
                const startIdx = scenes.findIndex(s => s.number === event.startScene);
                const endIdx = scenes.findIndex(s => s.number === event.endScene);
                return sceneIndex >= startIdx && sceneIndex <= endIdx;
            });
        }

        // Calculate event progress percentage
        function calculateEventProgress(event, sceneIndex) {
            const startIdx = scenes.findIndex(s => s.number === event.startScene);
            const endIdx = scenes.findIndex(s => s.number === event.endScene);
            const totalScenes = endIdx - startIdx + 1;
            const currentScene = sceneIndex - startIdx + 1;
            return Math.round((currentScene / totalScenes) * 100);
        }

        // Get event stage label
        function getEventStageLabel(progress) {
            if (progress < 33) return { label: 'Fresh', class: 'fresh' };
            if (progress < 75) return { label: 'Healing', class: 'healing' };
            return { label: 'Healed', class: 'healed' };
        }

        // Render story day cards in the cast profile modal
        function renderStoryDayCards(character) {
            const container = document.getElementById('storyDayCardsContainer');
            const storyDays = getStoryDaysForCharacter(character);
            const profile = castProfiles[character] || {};

            if (storyDays.length === 0) {
                container.innerHTML = '<div class="empty-state-small"><div class="empty-text-small">No scenes found for this character.</div></div>';
                return;
            }

            container.innerHTML = storyDays.map((dayData, dayIndex) => {
                const aggregated = aggregateStoryDay(character, dayData);
                const firstSceneIndex = dayData.scenes[0].index;
                const activeEvents = getActiveEventsForScene(character, firstSceneIndex);
                const imageKey = dayData.label;
                const image = profile.storyDayImages?.[imageKey];

                return `
                    <div class="story-day-card" data-day-index="${dayIndex}">
                        <div class="day-header">
                            <span class="day-label">${dayData.label}</span>
                            <span class="scene-count">${dayData.scenes.length} scene${dayData.scenes.length > 1 ? 's' : ''}</span>
                        </div>

                        <div class="reference-image" onclick="uploadStoryDayImage('${character}', '${imageKey}')">
                            ${image ? `<img src="${image}" alt="${dayData.label}" />` : ''}
                            <button class="upload-btn">+ Upload</button>
                        </div>

                        <div class="look-details">
                            <div class="detail-row">
                                <span class="detail-label">Hair:</span>
                                <span class="detail-value">${aggregated.hair || 'â€”'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Makeup:</span>
                                <span class="detail-value">${aggregated.makeup || 'â€”'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">SFX:</span>
                                <span class="detail-value">${aggregated.sfx || 'â€”'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Wardrobe:</span>
                                <span class="detail-value">${aggregated.wardrobe || 'â€”'}</span>
                            </div>
                        </div>

                        <div class="active-events">
                            ${activeEvents.length > 0
                                ? activeEvents.map(event => {
                                    const progress = calculateEventProgress(event, firstSceneIndex);
                                    const stage = getEventStageLabel(progress);
                                    return `<span class="event-badge ${stage.class}">âš¡ ${event.description}</span>`;
                                }).join(' ')
                                : '<span class="event-badge" style="background: rgba(255,255,255,0.05); color: var(--text-muted); border: 1px solid var(--glass-border);">No active events</span>'
                            }
                        </div>

                        <button class="expand-btn" onclick="expandDayCard(${dayIndex}, '${character}')">
                            View Scenes â–¼
                        </button>

                        <div class="expanded-scenes" id="expandedScenes${dayIndex}" style="display: none;">
                            ${dayData.scenes.map(({ scene, index }) => {
                                const state = characterStates[index]?.[character] || {};
                                return `
                                    <div class="scene-detail" onclick="jumpToScene(${index})">
                                        <strong>Scene ${scene.number}:</strong> ${scene.heading}
                                        <div class="scene-look">
                                            ${state.hair ? 'Hair: ' + state.hair : ''}
                                            ${state.makeup ? ' | Makeup: ' + state.makeup : ''}
                                            ${state.sfx ? ' | SFX: ' + state.sfx : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Expand/collapse day card
        function expandDayCard(dayIndex, character) {
            const expandedDiv = document.getElementById(`expandedScenes${dayIndex}`);
            if (expandedDiv.style.display === 'none') {
                expandedDiv.style.display = 'block';
            } else {
                expandedDiv.style.display = 'none';
            }
        }

        // Jump to scene from character timeline
        function jumpToScene(sceneIndex) {
            // Close the cast profile modal
            closeCastProfile();

            // Switch to script tab
            switchCenterTab('script');

            // Select the scene
            selectScene(sceneIndex);

            // Scroll to the scene in the script viewer
            setTimeout(() => {
                const sceneElement = document.getElementById(`scene-${scenes[sceneIndex].number}`);
                if (sceneElement) {
                    sceneElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        // Upload story day image
        function uploadStoryDayImage(character, dayLabel) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const base64 = e.target.result;
                        saveStoryDayImage(character, dayLabel, base64);
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        // Save story day image
        function saveStoryDayImage(character, dayLabel, base64) {
            if (!castProfiles[character]) {
                castProfiles[character] = { name: character };
            }
            if (!castProfiles[character].storyDayImages) {
                castProfiles[character].storyDayImages = {};
            }
            castProfiles[character].storyDayImages[dayLabel] = base64;
            saveProject();
            renderStoryDayCards(character);
        }

        // Upload reference image
        function uploadReferenceImage() {
            if (!currentCastMember) return;

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = function(e) {
                const files = Array.from(e.target.files);
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const base64 = e.target.result;
                        saveReferenceImage(currentCastMember, base64);
                    };
                    reader.readAsDataURL(file);
                });
            };
            input.click();
        }

        // Save reference image
        function saveReferenceImage(character, base64) {
            if (!castProfiles[character]) {
                castProfiles[character] = { name: character };
            }
            if (!castProfiles[character].referenceImages) {
                castProfiles[character].referenceImages = [];
            }
            castProfiles[character].referenceImages.push({
                id: Date.now(),
                url: base64
            });
            saveProject();
            renderReferenceImages(character);
        }

        // Render reference images
        function renderReferenceImages(character) {
            const container = document.getElementById('referenceImagesGrid');
            const profile = castProfiles[character] || {};
            const images = profile.referenceImages || [];

            container.innerHTML = images.map(img => `
                <div class="reference-image-item">
                    <img src="${img.url}" alt="Reference" onclick="viewImageFullscreen('${img.url}')" />
                </div>
            `).join('') + `
                <div class="reference-image-item upload-placeholder" onclick="uploadReferenceImage()">
                    + Upload
                </div>
            `;
        }

        // View image fullscreen (simple implementation)
        function viewImageFullscreen(url) {
            window.open(url, '_blank');
        }

        // Navigate days in timeline
        let currentDayOffset = 0;

        function navigatePreviousDay() {
            if (currentDayOffset > 0) {
                currentDayOffset--;
                updateDayNavigation();
            }
        }

        function navigateNextDay() {
            const storyDays = getStoryDaysForCharacter(currentCastMember);
            if (currentDayOffset < storyDays.length - 3) {
                currentDayOffset++;
                updateDayNavigation();
            }
        }

        function updateDayNavigation() {
            // This would scroll the story day cards container
            const container = document.getElementById('storyDayCardsContainer');
            const cardWidth = 296; // 280px + 16px gap
            container.scrollTo({
                left: currentDayOffset * cardWidth,
                behavior: 'smooth'
            });
        }

        // Print lookbook
        function printLookbook() {
            if (!currentCastMember) return;

            const character = currentCastMember;
            const profile = castProfiles[character] || {};
            const storyDays = getStoryDaysForCharacter(character);

            const printHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${character} - Lookbook</title>
                    <style>
                        @page { size: A4; margin: 20mm; }
                        body {
                            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                            color: #1a1a1a;
                            line-height: 1.6;
                        }
                        .lookbook-header {
                            text-align: center;
                            margin-bottom: 40px;
                            padding-bottom: 20px;
                            border-bottom: 2px solid #d4af7a;
                        }
                        .lookbook-header h1 {
                            margin: 0;
                            font-size: 2.5em;
                            color: #d4af7a;
                        }
                        .base-description {
                            font-style: italic;
                            color: #666;
                            margin-top: 10px;
                        }
                        .day-card {
                            page-break-inside: avoid;
                            margin-bottom: 30px;
                            border: 1px solid #ddd;
                            border-radius: 8px;
                            padding: 20px;
                        }
                        .day-header {
                            font-size: 1.5em;
                            font-weight: 700;
                            color: #d4af7a;
                            margin-bottom: 15px;
                        }
                        .reference-image {
                            width: 100%;
                            max-height: 400px;
                            object-fit: cover;
                            border-radius: 6px;
                            margin-bottom: 15px;
                        }
                        .look-details {
                            display: grid;
                            grid-template-columns: auto 1fr;
                            gap: 8px 16px;
                        }
                        .detail-label {
                            font-weight: 700;
                            color: #666;
                        }
                        .detail-value {
                            color: #1a1a1a;
                        }
                        .scenes-list {
                            margin-top: 15px;
                            padding-top: 15px;
                            border-top: 1px solid #eee;
                            font-size: 0.9em;
                            color: #666;
                        }
                    </style>
                </head>
                <body>
                    <div class="lookbook-header">
                        <h1>${character}</h1>
                        <p class="base-description">${profile.baseDescription || 'No base description'}</p>
                    </div>
                    ${storyDays.map(dayData => {
                        const aggregated = aggregateStoryDay(character, dayData);
                        const imageKey = dayData.label;
                        const image = profile.storyDayImages?.[imageKey];

                        return `
                            <div class="day-card">
                                <div class="day-header">${dayData.label}</div>
                                ${image ? `<img src="${image}" class="reference-image" />` : ''}
                                <div class="look-details">
                                    <span class="detail-label">Hair:</span>
                                    <span class="detail-value">${aggregated.hair || 'â€”'}</span>
                                    <span class="detail-label">Makeup:</span>
                                    <span class="detail-value">${aggregated.makeup || 'â€”'}</span>
                                    <span class="detail-label">SFX:</span>
                                    <span class="detail-value">${aggregated.sfx || 'â€”'}</span>
                                    <span class="detail-label">Wardrobe:</span>
                                    <span class="detail-value">${aggregated.wardrobe || 'â€”'}</span>
                                </div>
                                <div class="scenes-list">
                                    Scenes: ${dayData.scenes.map(s => s.scene.number).join(', ')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </body>
                </html>
            `;

            const printWindow = window.open('', '', 'width=800,height=600');
            printWindow.document.write(printHTML);
            printWindow.document.close();
            setTimeout(() => printWindow.print(), 250);
        }

        // ========== END: New Visual Timeline Functions ==========

        // ========== Cast Member Card Functions ==========

        // Toggle cast member card expanded/collapsed
        function toggleCastCard(cardId) {
            const card = document.getElementById('castCard' + cardId);
            if (card) {
                card.classList.toggle('expanded');
            }
        }

        // Toggle Scene Info section expand/collapse
        function toggleSceneInfo() {
            const section = document.getElementById('sceneInfoSection');
            if (!section) return;

            const isExpanded = section.classList.contains('expanded');
            const toggle = section.querySelector('.scene-info-toggle');

            if (isExpanded) {
                section.classList.remove('expanded');
                if (toggle) toggle.textContent = 'â–¶';
            } else {
                section.classList.add('expanded');
                if (toggle) toggle.textContent = 'â–¼';
            }
        }

        // Toggle category section expand/collapse
        function toggleCategory(categoryId) {
            const section = document.getElementById('category-' + categoryId);
            if (!section) return;

            const isExpanded = section.classList.contains('expanded');
            const toggle = section.querySelector('.category-toggle');

            if (isExpanded) {
                section.classList.remove('expanded');
                if (toggle) toggle.textContent = 'â–¶';
            } else {
                section.classList.add('expanded');
                if (toggle) toggle.textContent = 'â–¼';
            }
        }

        // Jump to category and expand it
        function jumpToCategory(categoryId) {
            const section = document.getElementById('category-' + categoryId);
            if (!section) return;

            // Expand if not already expanded
            if (!section.classList.contains('expanded')) {
                toggleCategory(categoryId);
            }

            // Scroll to section
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Highlight briefly
            section.style.transition = 'background 0.3s ease';
            section.style.background = 'rgba(212, 175, 122, 0.15)';
            setTimeout(() => {
                section.style.background = '';
            }, 1000);
        }

        // Update character field in scene
        // Auto-save when character fields change
        function updateCharacterField(character, field, value) {
            if (!characterStates[currentScene]) {
                characterStates[currentScene] = {};
            }
            if (!characterStates[currentScene][character]) {
                characterStates[currentScene][character] = {};
            }
            characterStates[currentScene][character][field] = value;

            // Auto-save after 1 second delay (debounced)
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                saveProject();
                showAutoSaveIndicator();
            }, 1000);
        }

        // Show brief save confirmation
        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            if (indicator) {
                indicator.style.display = 'flex';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 1500);
            }
        }

        // AI fill character fields (simple implementation - extracts from existing tags)
        function aiFillCharacterFields(character) {
            const sceneTags = scriptTags[currentScene] || [];
            const characterTags = sceneTags.filter(tag => tag.character === character);

            if (characterTags.length === 0) {
                alert('No tags found for ' + character + ' in this scene. Tag some text first!');
                return;
            }

            if (!characterStates[currentScene]) {
                characterStates[currentScene] = {};
            }
            if (!characterStates[currentScene][character]) {
                characterStates[currentScene][character] = {};
            }

            // Group tags by category
            characterTags.forEach(tag => {
                const field = tag.category;
                const currentValue = characterStates[currentScene][character][field] || '';
                const newValue = tag.text;

                // Append if not already present
                if (!currentValue.includes(newValue)) {
                    characterStates[currentScene][character][field] =
                        currentValue ? currentValue + ', ' + newValue : newValue;
                }
            });

            saveProject();
            renderBreakdownPanel();
            alert('Fields filled from tags for ' + character);
        }

        // ========== END: Cast Member Card Functions ==========

        // Cast profiles
        function openCastProfile(castMember) {
            currentCastMember = castMember;
            currentDayOffset = 0; // Reset day navigation

            const profile = castProfiles[castMember] || {
                name: castMember,
                baseDescription: ''
            };

            document.getElementById('castProfileTitle').textContent = `${castMember} - Cast Profile`;
            document.getElementById('castBaseDesc').value = profile.baseDescription || '';

            // Get scenes this character appears in
            const characterScenes = [];
            scenes.forEach((scene, index) => {
                const breakdown = sceneBreakdowns[index] || {};
                if (breakdown.cast && breakdown.cast.includes(castMember)) {
                    characterScenes.push({ scene, index });
                }
            });

            // Update scenes count
            const sceneNumbers = characterScenes.map(s => s.scene.number).join(', ');
            document.querySelector('.scenes-list').textContent =
                `${sceneNumbers} (${characterScenes.length} scenes)`;

            // Render NEW visual timeline with story day cards
            renderStoryDayCards(castMember);

            // Render continuity events (enhanced with progress bars)
            renderContinuityEvents(castMember);

            // Render reference images
            renderReferenceImages(castMember);

            document.getElementById('castProfileModal').classList.add('active');
        }
        
        function closeCastProfile() {
            document.getElementById('castProfileModal').classList.remove('active');
            currentCastMember = null;
        }
        
        function saveCastProfile() {
            if (!currentCastMember) return;

            // Save base description
            if (!castProfiles[currentCastMember]) {
                castProfiles[currentCastMember] = {
                    name: currentCastMember
                };
            }

            castProfiles[currentCastMember].baseDescription = document.getElementById('castBaseDesc').value;

            saveProject();
            renderCastPanel();
            alert('Profile saved!');
        }

        // ========== MANAGE LOOKS FUNCTIONS ==========

        let currentLookCharacter = null;

        function openManageLooks(character) {
            currentLookCharacter = character;
            document.getElementById('manageLooksTitle').textContent = `Look States - ${character}`;

            renderLooksList(character);

            document.getElementById('manageLooksModal').classList.add('active');
        }

        function closeManageLooks() {
            document.getElementById('manageLooksModal').classList.remove('active');
            currentLookCharacter = null;
        }

        function renderLooksList(character) {
            const looks = characterLooks[character] || [];
            const container = document.getElementById('looksList');

            if (looks.length === 0) {
                container.innerHTML = `
                    <div class="empty-state-small">
                        <div class="empty-icon-small">ðŸ‘”</div>
                        <div class="empty-text-small">No look states defined yet. Click "+ Add Look State" to create one.</div>
                    </div>
                `;
                return;
            }

            let html = '';
            looks.forEach(look => {
                const sceneRangeText = formatSceneRange(look.scenes);
                const complexityIcon = getComplexityIcon(look.complexity);
                const hasAppearanceData = Object.values(look.appearance || {}).some(v => v && v.trim());

                html += `
                    <div class="look-state-card">
                        <div class="look-state-header">
                            <div class="look-state-title">
                                <span class="look-state-name">${look.lookName || 'Untitled Look'}</span>
                                <span class="complexity-indicator">${complexityIcon}</span>
                            </div>
                            <div class="look-state-actions">
                                <button class="look-action-btn" onclick="editLook('${look.id}')" title="Edit">âœï¸</button>
                                <button class="look-action-btn delete" onclick="deleteLook('${look.id}')" title="Delete">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                        <div class="look-state-details">
                            <div class="look-detail-row">
                                <span class="look-detail-label">Scenes:</span>
                                <span class="look-detail-value">${sceneRangeText}</span>
                            </div>
                            ${look.storyTime ? `
                                <div class="look-detail-row">
                                    <span class="look-detail-label">Story Time:</span>
                                    <span class="look-detail-value">${look.storyTime}</span>
                                </div>
                            ` : ''}
                            ${hasAppearanceData ? `
                                <div class="look-detail-row">
                                    <span class="look-detail-label">Defined:</span>
                                    <span class="look-detail-value">${getDefinedFields(look.appearance)}</span>
                                </div>
                            ` : ''}
                            ${look.mustMatchScenes ? `
                                <div class="look-detail-row">
                                    <span class="look-detail-label">Must Match:</span>
                                    <span class="look-detail-value">${look.mustMatchScenes} scenes</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function formatSceneRange(scenes) {
            if (!scenes || scenes.length === 0) return 'No scenes';

            const sorted = [...scenes].sort((a, b) => a - b);
            const ranges = [];
            let start = sorted[0];
            let end = sorted[0];

            for (let i = 1; i < sorted.length; i++) {
                if (sorted[i] === end + 1) {
                    end = sorted[i];
                } else {
                    ranges.push(start === end ? `${start}` : `${start}-${end}`);
                    start = sorted[i];
                    end = sorted[i];
                }
            }
            ranges.push(start === end ? `${start}` : `${start}-${end}`);

            return 'Scenes ' + ranges.join(', ');
        }

        function getComplexityIcon(complexity) {
            switch (complexity) {
                case 'low': return 'ðŸŸ¢';
                case 'medium': return 'ðŸŸ¡';
                case 'high': return 'ðŸ”´';
                default: return 'âšª';
            }
        }

        function getDefinedFields(appearance) {
            if (!appearance) return 'None';
            const fields = [];
            if (appearance.hair) fields.push('Hair');
            if (appearance.makeup) fields.push('Makeup');
            if (appearance.sfx) fields.push('SFX');
            if (appearance.wardrobe) fields.push('Wardrobe');
            if (appearance.physicalState) fields.push('Physical State');
            return fields.length > 0 ? fields.join(', ') : 'None';
        }

        function addNewLook() {
            if (!currentLookCharacter) return;

            // Open edit modal for new look (no lookId)
            openEditLook(currentLookCharacter, null);
        }

        function editLook(lookId) {
            if (!currentLookCharacter) return;

            // Open edit modal for existing look
            openEditLook(currentLookCharacter, lookId);
        }

        function deleteLook(lookId) {
            if (!currentLookCharacter) return;

            if (!confirm('Are you sure you want to delete this look state?')) return;

            const looks = characterLooks[currentLookCharacter] || [];
            const index = looks.findIndex(l => l.id === lookId);

            if (index !== -1) {
                looks.splice(index, 1);
                saveProject();
                renderLooksList(currentLookCharacter);
            }
        }

        // ========== EDIT LOOK STATE MODAL ==========

        let currentEditingLook = null;
        let currentEditingLookCharacter = null;

        function openEditLook(character, lookId = null) {
            currentEditingLookCharacter = character;
            currentEditingLook = lookId;

            // Set modal title
            const isNew = lookId === null;
            document.getElementById('editLookTitle').textContent = isNew ? 'Create New Look State' : 'Edit Look State';

            // Get the look data if editing existing
            let lookData = null;
            if (!isNew) {
                const looks = characterLooks[character] || [];
                lookData = looks.find(l => l.id === lookId);
            }

            // Populate form fields
            document.getElementById('lookName').value = lookData?.lookName || '';
            document.getElementById('lookStoryTime').value = lookData?.storyTime || '';
            document.getElementById('lookHair').value = lookData?.appearance?.hair || '';
            document.getElementById('lookMakeup').value = lookData?.appearance?.makeup || '';
            document.getElementById('lookSfx').value = lookData?.appearance?.sfx || '';
            document.getElementById('lookWardrobe').value = lookData?.appearance?.wardrobe || '';
            document.getElementById('lookPhysicalState').value = lookData?.appearance?.physicalState || '';
            document.getElementById('lookComplexity').value = lookData?.complexity || 'low';
            document.getElementById('lookStoryContext').value = lookData?.storyContext || '';

            // Render scene checkboxes
            renderSceneCheckboxes(lookData?.scenes || []);

            // Render script evidence lists
            renderScriptQuotes(lookData?.scriptEvidence?.quotes || []);
            renderImplications(lookData?.scriptEvidence?.implications || []);

            // Show modal
            document.getElementById('editLookModal').classList.add('active');
        }

        function closeEditLook() {
            document.getElementById('editLookModal').classList.remove('active');
            currentEditingLook = null;
            currentEditingLookCharacter = null;
        }

        function renderSceneCheckboxes(selectedScenes = []) {
            const container = document.getElementById('sceneCheckboxes');
            let html = '';

            scenes.forEach((scene, index) => {
                const sceneNumber = scene.number;
                const isChecked = selectedScenes.includes(sceneNumber);
                const heading = scene.heading.length > 50 ? scene.heading.substring(0, 50) + '...' : scene.heading;

                html += `
                    <label class="scene-checkbox-item">
                        <input type="checkbox"
                               class="scene-checkbox"
                               value="${sceneNumber}"
                               ${isChecked ? 'checked' : ''}
                               onchange="updateSceneCount()">
                        <span class="scene-checkbox-label">
                            <span class="scene-number">Scene ${sceneNumber}</span>
                            <span class="scene-heading">${heading}</span>
                        </span>
                    </label>
                `;
            });

            container.innerHTML = html;
            updateSceneCount();
        }

        function updateSceneCount() {
            const checkboxes = document.querySelectorAll('.scene-checkbox:checked');
            const count = checkboxes.length;
            document.getElementById('selectedScenesCount').textContent = `${count} scene${count !== 1 ? 's' : ''} selected`;
        }

        function getSelectedScenes() {
            const checkboxes = document.querySelectorAll('.scene-checkbox:checked');
            return Array.from(checkboxes).map(cb => parseInt(cb.value));
        }

        // Script Quotes Management
        let currentQuotes = [];

        function renderScriptQuotes(quotes = []) {
            currentQuotes = [...quotes];
            const container = document.getElementById('scriptQuotesList');

            if (currentQuotes.length === 0) {
                container.innerHTML = '<div class="empty-evidence">No quotes added yet</div>';
                return;
            }

            let html = '';
            currentQuotes.forEach((quote, index) => {
                html += `
                    <div class="evidence-item">
                        <div class="evidence-text">${quote}</div>
                        <button class="evidence-remove-btn" onclick="removeScriptQuote(${index})">Ã—</button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function addScriptQuote() {
            const quote = prompt('Enter script quote:');
            if (quote && quote.trim()) {
                currentQuotes.push(quote.trim());
                renderScriptQuotes(currentQuotes);
            }
        }

        function removeScriptQuote(index) {
            currentQuotes.splice(index, 1);
            renderScriptQuotes(currentQuotes);
        }

        // Implications Management
        let currentImplications = [];

        function renderImplications(implications = []) {
            currentImplications = [...implications];
            const container = document.getElementById('implicationsList');

            if (currentImplications.length === 0) {
                container.innerHTML = '<div class="empty-evidence">No implications added yet</div>';
                return;
            }

            let html = '';
            currentImplications.forEach((implication, index) => {
                html += `
                    <div class="evidence-item">
                        <div class="evidence-text">${implication}</div>
                        <button class="evidence-remove-btn" onclick="removeImplication(${index})">Ã—</button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function addImplication() {
            const implication = prompt('Enter implication from script:');
            if (implication && implication.trim()) {
                currentImplications.push(implication.trim());
                renderImplications(currentImplications);
            }
        }

        function removeImplication(index) {
            currentImplications.splice(index, 1);
            renderImplications(currentImplications);
        }

        function saveLookState() {
            if (!currentEditingLookCharacter) return;

            // Validate required fields
            const lookName = document.getElementById('lookName').value.trim();
            if (!lookName) {
                alert('Please enter a look name');
                return;
            }

            const selectedScenes = getSelectedScenes();
            if (selectedScenes.length === 0) {
                alert('Please select at least one scene');
                return;
            }

            // Build the look object
            const lookData = {
                id: currentEditingLook || 'look-' + Date.now(),
                lookName: lookName,
                scenes: selectedScenes,
                storyTime: document.getElementById('lookStoryTime').value.trim(),
                appearance: {
                    hair: document.getElementById('lookHair').value.trim(),
                    makeup: document.getElementById('lookMakeup').value.trim(),
                    sfx: document.getElementById('lookSfx').value.trim(),
                    wardrobe: document.getElementById('lookWardrobe').value.trim(),
                    physicalState: document.getElementById('lookPhysicalState').value.trim()
                },
                scriptEvidence: {
                    quotes: currentQuotes,
                    implications: currentImplications
                },
                complexity: document.getElementById('lookComplexity').value,
                mustMatchScenes: selectedScenes.length,
                storyContext: document.getElementById('lookStoryContext').value.trim()
            };

            // Initialize character looks array if needed
            if (!characterLooks[currentEditingLookCharacter]) {
                characterLooks[currentEditingLookCharacter] = [];
            }

            // Update or add the look
            const looks = characterLooks[currentEditingLookCharacter];
            if (currentEditingLook) {
                // Update existing
                const index = looks.findIndex(l => l.id === currentEditingLook);
                if (index !== -1) {
                    looks[index] = lookData;
                }
            } else {
                // Add new
                looks.push(lookData);
            }

            // Save and refresh
            saveProject();
            renderLooksList(currentEditingLookCharacter);
            closeEditLook();

            // If manage looks modal is open, keep it open
            if (document.getElementById('manageLooksModal').classList.contains('active')) {
                // Already open, just refreshed
            }
        }

        // Render script
        function renderScript() {
            if (!scriptText) return;
            
            const container = document.getElementById('scriptContent');
            const lines = scriptText.split('\n');
            let html = '';
            let inScene = false;
            let sceneIdx = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                const isSceneHeading = scenes.some(s => s.lineNumber === i);
                
                if (isSceneHeading) {
                    if (inScene) html += '</div>';
                    
                    const scene = scenes[sceneIdx];
                    html += `<div class="script-scene" id="scene-${scene.number}">`;
                    html += `<div class="scene-header-wrapper" onclick="selectSceneFromScript(${sceneIdx})" style="cursor: pointer;">`;
                    html += `<span class="scene-number-badge">Scene ${scene.number}</span>`;
                    html += `<div class="script-scene-heading">${trimmed}</div>`;
                    html += `</div>`;
                    
                    inScene = true;
                    sceneIdx++;
                } else if (trimmed) {
                    if (trimmed === trimmed.toUpperCase() && trimmed.length < 30 && !trimmed.includes('.')) {
                        html += `<div class="script-character">${trimmed}</div>`;
                    } else if (trimmed.startsWith('(') && trimmed.endsWith(')')) {
                        html += `<div class="script-parenthetical">${trimmed}</div>`;
                    } else if (trimmed.includes('CUT TO:') || trimmed.includes('FADE')) {
                        html += `<div class="script-transition">${trimmed}</div>`;
                    } else {
                        const prevLine = i > 0 ? lines[i - 1].trim() : '';
                        if (prevLine === prevLine.toUpperCase() && prevLine.length < 30) {
                            html += `<div class="script-dialogue">${trimmed}</div>`;
                        } else {
                            html += `<div class="script-action">${trimmed}</div>`;
                        }
                    }
                }
            }
            
            if (inScene) html += '</div>';
            container.innerHTML = html;
        }
        
        // Import modal
        function openImportModal() {
            document.getElementById('importModal').classList.add('active');
            if (currentProject.scriptContent) {
                document.getElementById('scriptInput').value = currentProject.scriptContent;
            }
        }
        
        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
        }
        
        async function processScript() {
            const text = document.getElementById('scriptInput').value;
            if (!text.trim()) {
                alert('Please paste your screenplay');
                return;
            }
            
            const btn = document.getElementById('importBtn');
            const status = document.getElementById('importStatus');
            btn.disabled = true;
            btn.textContent = 'Processing...';
            status.style.display = 'block';
            status.textContent = 'ðŸ“ Importing script and detecting scenes...';
            
            scriptText = text;
            currentProject.scriptContent = text;
            
            // Detect scenes
            scenes = detectScenes(text);
            status.textContent = `âœ… Found ${scenes.length} scenes. Detecting character introductions...`;
            
            // Detect character introductions
            const intros = await detectCharacterIntroductions(text);
            Object.keys(intros).forEach(charName => {
                if (!castProfiles[charName]) {
                    castProfiles[charName] = {
                        name: charName,
                        baseDescription: intros[charName].description,
                        makeup: '',
                        wardrobe: '',
                        scenes: [intros[charName].firstScene]
                    };
                }
            });
            
            status.textContent = `âœ… Detected ${Object.keys(intros).length} character introductions. Ready!`;
            
            loadScript(text);
            
            setTimeout(() => {
                closeImportModal();
                btn.disabled = false;
                btn.textContent = 'Import & Analyze';
                status.style.display = 'none';
            }, 1000);
        }
        
        // Search
        function handleSceneSearch(e) {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scene-item').forEach((item, index) => {
                const heading = scenes[index].heading.toLowerCase();
                item.style.display = heading.includes(term) ? 'block' : 'none';
            });
        }
        
        // Zoom
        function zoomIn() {
            const el = document.querySelector('.script-content');
            const size = parseFloat(window.getComputedStyle(el).fontSize);
            el.style.fontSize = (size * 1.1) + 'px';
        }
        
        function zoomOut() {
            const el = document.querySelector('.script-content');
            const size = parseFloat(window.getComputedStyle(el).fontSize);
            el.style.fontSize = (size * 0.9) + 'px';
        }
        
        // Export
        function exportData() {
            const data = {
                project: currentProject,
                scenes: scenes,
                sceneBreakdowns: sceneBreakdowns,
                castProfiles: castProfiles,
                characterStates: characterStates,
                continuityEvents: continuityEvents,
                sceneTimeline: sceneTimeline,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentProject.name.replace(/\s+/g, '-')}-breakdown.json`;
            a.click();
        }

        // Save scene breakdown with visual feedback
        function saveSceneBreakdown() {
            if (currentScene === null) return;

            saveProject();

            // Visual feedback
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = 'âœ“ Saved!';
            btn.style.background = 'linear-gradient(135deg, rgba(82, 193, 134, 0.25), rgba(52, 211, 153, 0.25))';

            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.style.background = 'linear-gradient(135deg, rgba(82, 193, 134, 0.15), rgba(52, 211, 153, 0.15))';
            }, 1500);
        }

        // Save project
        function saveProject() {
            currentProject.sceneBreakdowns = sceneBreakdowns;
            currentProject.castProfiles = castProfiles;
            currentProject.characterStates = characterStates;
            currentProject.characterLooks = characterLooks;
            currentProject.continuityEvents = continuityEvents;
            currentProject.sceneTimeline = sceneTimeline;
            currentProject.scenes = scenes;
            currentProject.scriptTags = scriptTags;

            localStorage.setItem('currentProject', JSON.stringify(currentProject));

            const projects = JSON.parse(localStorage.getItem('checksHappyProjects') || '[]');
            const index = projects.findIndex(p => p.id === currentProject.id);
            if (index !== -1) {
                projects[index] = currentProject;
            } else {
                projects.push(currentProject);
            }
            localStorage.setItem('checksHappyProjects', JSON.stringify(projects));
        }

        // ==========================================
        // TAGGING SYSTEM
        // ==========================================

        // Text Selection Handler
        document.addEventListener('DOMContentLoaded', function() {
            const scriptContent = document.getElementById('scriptContent');
            if (scriptContent) {
                scriptContent.addEventListener('mouseup', handleTextSelection);
            }

            // Close popups on Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeTagPopup();
                    closeContextMenu();
                }
            });

            // Close context menu on click outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.tag-context-menu')) {
                    closeContextMenu();
                }
            });
        });

        function handleTextSelection(e) {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            // Don't show popup if no text selected or clicking on existing tag
            if (!selectedText || e.target.classList.contains('tag-highlight')) {
                return;
            }

            // Get the full context (sentence or paragraph)
            const range = selection.getRangeAt(0);
            const container = range.commonAncestorContainer;
            const element = container.nodeType === 3 ? container.parentElement : container;

            // Don't allow tagging scene headings
            if (element.classList.contains('script-scene-heading')) {
                alert('Cannot tag scene headings');
                return;
            }

            // Capture full context
            const fullContext = captureContext(element, selectedText);

            // Detect character from context
            const detectedCharacter = detectCharacter(fullContext);

            // Store selection data
            currentSelection = {
                selectedText: selectedText,
                fullContext: fullContext,
                element: element,
                range: range,
                detectedCharacter: detectedCharacter
            };

            // Show tag popup
            showTagPopup();
        }

        function captureContext(element, selectedText) {
            let context = element.textContent;

            // If it's an action line, capture the full sentence or paragraph
            if (element.classList.contains('script-action')) {
                // Check if it's a character introduction (all caps name with description in parens)
                const charIntroPattern = /^[A-Z][A-Z\s]+\s*\([^)]+\)/;
                if (charIntroPattern.test(context)) {
                    // Capture full paragraph (all contiguous action lines)
                    let fullParagraph = context;
                    let nextSibling = element.nextElementSibling;
                    while (nextSibling && nextSibling.classList.contains('script-action')) {
                        fullParagraph += ' ' + nextSibling.textContent;
                        nextSibling = nextSibling.nextElementSibling;
                    }
                    return fullParagraph.trim();
                }

                // Otherwise capture the full sentence
                const sentences = context.match(/[^.!?]+[.!?]+/g) || [context];
                for (let sentence of sentences) {
                    if (sentence.includes(selectedText)) {
                        return sentence.trim();
                    }
                }
            }

            return context.trim();
        }

        function detectCharacter(context) {
            // Match words that are 2+ letters, all uppercase, not scene keywords
            const sceneKeywords = ['INT', 'EXT', 'DAY', 'NIGHT', 'CONTINUOUS', 'LATER', 'MORNING', 'AFTERNOON', 'EVENING', 'DAWN', 'DUSK'];
            const capsWords = context.match(/\b[A-Z]{2,}[A-Z\s]*\b/g);

            if (capsWords) {
                for (let word of capsWords) {
                    word = word.trim();
                    if (!sceneKeywords.includes(word) && characters.has(word)) {
                        return word;
                    }
                }
            }

            return null;
        }

        function showTagPopup() {
            if (!currentSelection) return;

            // Populate popup
            document.getElementById('tagSelectedText').textContent = currentSelection.selectedText;
            document.getElementById('tagContext').value = currentSelection.fullContext;
            document.getElementById('tagCategory').value = 'makeup'; // Default to makeup

            // Reset character field
            document.getElementById('characterField').style.display = 'none';

            // Populate character dropdown
            const characterSelect = document.getElementById('tagCharacter');
            characterSelect.innerHTML = '<option value="">-- Select Character --</option>';

            // Add current scene cast if available
            if (currentScene !== null && sceneBreakdowns[currentScene]?.cast) {
                sceneBreakdowns[currentScene].cast.forEach(castMember => {
                    const option = document.createElement('option');
                    option.value = castMember;
                    option.textContent = castMember;
                    if (castMember === currentSelection.detectedCharacter) {
                        option.selected = true;
                    }
                    characterSelect.appendChild(option);
                });
            }

            // Show character field for makeup/wardrobe
            handleCategoryChange();

            // Show popup
            document.getElementById('tagPopup').classList.add('active');
        }

        function closeTagPopup() {
            document.getElementById('tagPopup').classList.remove('active');
            currentSelection = null;

            // Reset form
            document.getElementById('tagCategory').value = 'makeup';
            document.getElementById('tagCharacter').value = '';
            document.getElementById('tagContext').value = '';
            document.querySelector('input[name="continuity"][value="oneoff"]').checked = true;
            document.getElementById('characterField').style.display = 'none';
            document.getElementById('linkExistingOption').style.display = 'none';
            document.getElementById('existingEvents').style.display = 'none';
        }

        function handleCategoryChange() {
            const category = document.getElementById('tagCategory').value;
            const characterField = document.getElementById('characterField');
            const linkOption = document.getElementById('linkExistingOption');

            // Show character field for hair, makeup, sfx, wardrobe
            if (['hair', 'makeup', 'sfx', 'wardrobe'].includes(category)) {
                characterField.style.display = 'block';

                // Check if selected character has continuity events
                const character = document.getElementById('tagCharacter').value;
                if (character && continuityEvents[character]?.length > 0) {
                    linkOption.style.display = 'block';
                    populateExistingEvents(character);
                } else {
                    linkOption.style.display = 'none';
                }
            } else {
                characterField.style.display = 'none';
                linkOption.style.display = 'none';
            }
        }

        function populateExistingEvents(character) {
            const eventsSelect = document.getElementById('existingEvents');
            eventsSelect.innerHTML = '<option value="">-- Select Event --</option>';

            if (continuityEvents[character]) {
                continuityEvents[character].forEach(event => {
                    const option = document.createElement('option');
                    option.value = event.id;
                    option.textContent = `${event.description} (Sc. ${event.startScene} - ${event.endScene || '?'})`;
                    eventsSelect.appendChild(option);
                });
            }

            // Show/hide events dropdown based on radio selection
            document.querySelectorAll('input[name="continuity"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.value === 'link') {
                        eventsSelect.style.display = 'block';
                    } else {
                        eventsSelect.style.display = 'none';
                    }
                });
            });
        }

        function saveTag() {
            if (!currentSelection || currentScene === null) return;

            const category = document.getElementById('tagCategory').value;
            const character = document.getElementById('tagCharacter').value;
            const context = document.getElementById('tagContext').value;
            const continuityType = document.querySelector('input[name="continuity"]:checked').value;
            const continuityEventId = continuityType === 'link' ? document.getElementById('existingEvents').value : null;

            // Validate: makeup/wardrobe must have character
            if ((category === 'makeup' || category === 'wardrobe') && !character) {
                alert('Please select a character for makeup/wardrobe tags');
                return;
            }

            // Create tag object
            const tag = {
                id: Date.now() + Math.random(),
                sceneIndex: currentScene,
                sceneNumber: scenes[currentScene].sceneNumber,
                category: category,
                selectedText: currentSelection.selectedText,
                fullContext: context,
                character: character || null,
                continuityType: continuityType,
                continuityEventId: continuityEventId,
                elementId: currentSelection.element.id || `element-${Date.now()}`,
                created: Date.now()
            };

            // Ensure element has an ID
            if (!currentSelection.element.id) {
                currentSelection.element.id = tag.elementId;
            }

            // Store tag
            if (!scriptTags[currentScene]) {
                scriptTags[currentScene] = [];
            }
            scriptTags[currentScene].push(tag);

            // Apply highlight
            applyHighlight(tag);

            // Add to scene breakdown
            addTagToBreakdown(tag);

            // Handle continuity
            if (continuityType === 'create') {
                // Create new continuity event (you can expand this later)
                alert('Continuity event creation will open the continuity modal');
            } else if (continuityType === 'link' && continuityEventId) {
                // Link to existing event
                linkTagToEvent(tag, continuityEventId);
            }

            // Update displays
            renderMarginIndicators();
            renderTagsPanel();
            saveProject();
            closeTagPopup();
        }

        function applyHighlight(tag) {
            // Find the element and highlight the text
            const element = document.getElementById(tag.elementId);
            if (!element) return;

            // Find and wrap the selected text
            const text = element.innerHTML;
            const selectedText = tag.selectedText;

            // Check if already highlighted
            if (text.includes(`data-tag-id="${tag.id}"`)) return;

            // Escape special regex characters in the selected text
            const escapedText = selectedText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Wrap the text
            const highlightedText = `<span class="tag-highlight" data-tag-id="${tag.id}" data-category="${tag.category}" onclick="event.stopPropagation();" oncontextmenu="showTagContextMenu(event, '${tag.id}'); return false;">${selectedText}</span>`;

            const newText = text.replace(new RegExp(escapedText, 'i'), highlightedText);
            element.innerHTML = newText;
        }

        function addTagToBreakdown(tag) {
            if (!sceneBreakdowns[tag.sceneIndex]) {
                sceneBreakdowns[tag.sceneIndex] = {
                    cast: [],
                    hair: [],
                    makeup: [],
                    sfx: [],
                    health: [],
                    injuries: [],
                    stunts: [],
                    weather: [],
                    wardrobe: [],
                    extras: []
                };
            }

            const breakdown = sceneBreakdowns[tag.sceneIndex];
            const categoryKey = tag.category;

            if (breakdown[categoryKey] && !breakdown[categoryKey].includes(tag.selectedText)) {
                breakdown[categoryKey].push(tag.selectedText);
            }

            // DO NOT add to cast automatically - tags are production elements, not cast members
            // Cast members should only be added via AI Synopsis or manual Scene Breakdown editing
            // if (tag.character && !breakdown.cast.includes(tag.character)) {
            //     breakdown.cast.push(tag.character);
            // }
        }

        function linkTagToEvent(tag, eventId) {
            // Find the event and add tag reference
            if (tag.character && continuityEvents[tag.character]) {
                const event = continuityEvents[tag.character].find(e => e.id === eventId);
                if (event) {
                    if (!event.linkedTags) event.linkedTags = [];
                    event.linkedTags.push(tag.id);
                }
            }
        }

        function renderMarginIndicators() {
            // Add margin indicators to the script for each tag
            Object.keys(scriptTags).forEach(sceneIndex => {
                scriptTags[sceneIndex].forEach(tag => {
                    const element = document.getElementById(tag.elementId);
                    if (!element) return;

                    // Check if indicator already exists
                    if (element.querySelector(`[data-indicator-id="${tag.id}"]`)) return;

                    // Create indicator
                    const category = categories.find(c => c.id === tag.category);
                    const indicator = document.createElement('div');
                    indicator.className = 'margin-indicator' + (tag.continuityEventId ? ' continuity' : '');
                    indicator.style.background = category?.color || '#667eea';
                    indicator.setAttribute('data-indicator-id', tag.id);
                    indicator.onclick = () => jumpToTag(tag.id);

                    // Add character initial or category icon
                    if (tag.character) {
                        indicator.textContent = tag.character.charAt(0);
                    } else {
                        indicator.textContent = category?.icon || 'ðŸ“Œ';
                    }

                    // Add to element
                    let indicators = element.querySelector('.margin-indicators');
                    if (!indicators) {
                        indicators = document.createElement('div');
                        indicators.className = 'margin-indicators';
                        element.style.position = 'relative';
                        element.insertBefore(indicators, element.firstChild);
                    }
                    indicators.appendChild(indicator);
                });
            });
        }

        function renderTagsPanel() {
            // No-op: Tags tab has been removed
            // This function is kept for backward compatibility with existing code that calls it
        }

        function filterTags() {
            renderTagsPanel();
        }

        function jumpToTag(tagId) {
            // Find tag
            let foundTag = null;
            for (let sceneIndex in scriptTags) {
                const tag = scriptTags[sceneIndex].find(t => t.id === tagId || t.id.toString() === tagId);
                if (tag) {
                    foundTag = tag;
                    break;
                }
            }

            if (!foundTag) return;

            // Switch to that scene
            const scene = scenes[foundTag.sceneIndex];
            if (scene) {
                selectScene(scene);
            }

            // Scroll to highlight
            setTimeout(() => {
                const highlight = document.querySelector(`[data-tag-id="${tagId}"]`);
                if (highlight) {
                    highlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    highlight.style.animation = 'pulse 1s ease-in-out';
                }
            }, 300);
        }

        function editTag(tagId) {
            alert('Edit tag functionality - to be implemented');
        }

        function deleteTag(tagId) {
            if (!confirm('Delete this tag?')) return;

            // Find and remove tag
            for (let sceneIndex in scriptTags) {
                scriptTags[sceneIndex] = scriptTags[sceneIndex].filter(t => t.id !== tagId && t.id.toString() !== tagId);
                if (scriptTags[sceneIndex].length === 0) {
                    delete scriptTags[sceneIndex];
                }
            }

            // Remove highlight
            const highlight = document.querySelector(`[data-tag-id="${tagId}"]`);
            if (highlight) {
                const parent = highlight.parentNode;
                parent.innerHTML = parent.innerHTML.replace(highlight.outerHTML, highlight.textContent);
            }

            // Remove indicator
            const indicator = document.querySelector(`[data-indicator-id="${tagId}"]`);
            if (indicator) {
                indicator.remove();
            }

            renderTagsPanel();
            saveProject();
        }


        // Context Menu
        let currentContextTagId = null;

        function showTagContextMenu(event, tagId) {
            event.preventDefault();
            currentContextTagId = tagId;

            const menu = document.getElementById('tagContextMenu');
            menu.style.display = 'block';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
        }

        function closeContextMenu() {
            document.getElementById('tagContextMenu').style.display = 'none';
            currentContextTagId = null;
        }

        function editTagFromContext() {
            if (currentContextTagId) {
                editTag(currentContextTagId);
            }
            closeContextMenu();
        }

        function removeTagFromContext() {
            if (currentContextTagId) {
                deleteTag(currentContextTagId);
            }
            closeContextMenu();
        }

        function jumpToTagsTab() {
            switchTab('tags');
            if (currentContextTagId) {
                // Highlight the tag card
                setTimeout(() => {
                    const card = document.querySelector(`[onclick*="${currentContextTagId}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        card.style.animation = 'pulse 1s ease-in-out';
                    }
                }, 300);
            }
            closeContextMenu();
        }

        function linkToContinuityFromContext() {
            alert('Link to continuity - to be implemented');
            closeContextMenu();
        }

        function renderAllHighlights() {
            console.log('Rendering all highlights...');
            console.log('Script tags:', scriptTags);

            // Wait for script to be fully rendered
            setTimeout(() => {
                let totalHighlighted = 0;

                Object.keys(scriptTags).forEach(sceneIndex => {
                    const sceneTags = scriptTags[sceneIndex];
                    console.log(`Scene ${sceneIndex} has ${sceneTags.length} tags`);

                    sceneTags.forEach((tag, index) => {
                        console.log(`Applying highlight ${index + 1}:`, tag.selectedText);
                        applyAITagHighlight(tag);
                        totalHighlighted++;
                    });
                });

                console.log(`âœ“ Applied ${totalHighlighted} highlights`);

                // Apply margin indicators after all highlights
                setTimeout(() => {
                    renderMarginIndicators();
                }, 300);
            }, 800);
        }

        // Add CSS animation for pulse effect
        const styleTag = document.createElement('style');
        styleTag.textContent = `
            @keyframes pulse {
                0%, 100% { opacity: 1; transform: scale(1); }
                50% { opacity: 0.7; transform: scale(1.05); }
            }
        `;
        document.head.appendChild(styleTag);

        // ==========================================
        // SCENE METADATA FUNCTIONS
        // ==========================================

        function updateSceneMetadata(sceneIndex, field, value) {
            if (!scenes[sceneIndex]) return;

            scenes[sceneIndex][field] = value;

            // Auto-save with visual feedback
            saveProject();
            console.log(`Auto-saved: Scene ${scenes[sceneIndex].number} ${field} = ${value}`);

            // Re-render scene list to update the read-only overview
            renderSceneList();

            // Scroll back to active scene
            if (currentScene === sceneIndex) {
                setTimeout(() => {
                    const sceneEl = document.querySelector('.scene-item.active');
                    if (sceneEl) {
                        sceneEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 100);
            }
        }

        function extractLocation(heading, sceneIndex = null) {
            // Check for "SAME" - inherit from previous scene
            const h = heading.toUpperCase();
            if ((h.includes('SAME') || h.includes('CONTINUOUS')) && sceneIndex !== null && sceneIndex > 0) {
                const previousScene = scenes[sceneIndex - 1];
                if (previousScene && previousScene.location) {
                    return previousScene.location;
                }
            }

            // Extract location from scene heading
            // e.g., "INT. KITCHEN - MORNING" -> "KITCHEN"
            const match = heading.match(/(?:INT\.|EXT\.|INT\/EXT\.|I\/E\.)\s+([^-]+)/i);
            if (match) {
                return match[1].trim();
            }
            return '';
        }

        // Auto-detect time of day from heading
        function detectTimeOfDay(heading, sceneIndex = null) {
            const h = heading.toUpperCase();

            // Check for "SAME" or "CONTINUOUS" - inherit from previous scene
            if ((h.includes('SAME') || h.includes('CONTINUOUS') || h.includes('CONT\'D')) && sceneIndex !== null && sceneIndex > 0) {
                const previousScene = scenes[sceneIndex - 1];
                if (previousScene && previousScene.timeOfDay) {
                    console.log(`Scene ${sceneIndex}: Inherited time "${previousScene.timeOfDay}" from previous scene`);
                    return previousScene.timeOfDay;
                }
            }

            // Standard detection
            if (h.includes('MORNING')) return 'Morning';
            if (h.includes('LATE MORNING')) return 'Late Morning';
            if (h.includes('AFTERNOON')) return 'Afternoon';
            if (h.includes('LATE AFTERNOON')) return 'Late Afternoon';
            if (h.includes('EVENING')) return 'Evening';
            if (h.includes('NIGHT')) return 'Night';
            if (h.includes('LATE NIGHT')) return 'Late Night';
            if (h.includes('DAWN')) return 'Morning';
            if (h.includes('DUSK')) return 'Evening';
            if (h.includes('DAY')) return 'Day';
            return '';
        }

        function detectIntExt(heading) {
            const h = heading.toUpperCase();
            if (h.includes('INT/EXT') || h.includes('I/E')) return 'INT/EXT';
            if (h.includes('INT.') || h.includes('INTERIOR')) return 'INT';
            if (h.includes('EXT.') || h.includes('EXTERIOR')) return 'EXT';
            return '';
        }

        // ==========================================
        // CHARACTER SCENE-SPECIFIC BREAKDOWN
        // ==========================================

        function loadSceneDetails() {
            const sceneIndex = parseInt(document.getElementById('sceneSelector').value);
            if (isNaN(sceneIndex)) return;

            const character = currentCastMember;
            const scene = scenes[sceneIndex];

            // Initialize character data for this scene if needed
            if (!scene.characters) scene.characters = {};
            if (!scene.characters[character]) {
                scene.characters[character] = {
                    hair: '',
                    makeup: '',
                    sfx: '',
                    wardrobe: '',
                    notes: ''
                };
            }

            const charData = scene.characters[character];

            // Get tags for this character in this scene
            const sceneTags = scriptTags[sceneIndex] || [];
            const hairTags = sceneTags.filter(t => t.category === 'hair' && t.character === character);
            const makeupTags = sceneTags.filter(t => t.category === 'makeup' && t.character === character);
            const sfxTags = sceneTags.filter(t => t.category === 'sfx' && t.character === character);
            const wardrobeTags = sceneTags.filter(t => t.category === 'wardrobe' && t.character === character);

            const container = document.getElementById('sceneDetailsContainer');
            container.innerHTML = `
                <div class="scene-detail-section">
                    <div class="detail-header">
                        <div class="detail-scene-info">Scene ${scene.number}: ${scene.heading}</div>
                        ${scene.storyDay ? `<div class="detail-story-day">${scene.storyDay}</div>` : ''}
                    </div>

                    <!-- HAIR -->
                    <div class="detail-field">
                        <div class="detail-field-header">
                            <label class="detail-label">ðŸ’‡ Hair</label>
                            <button class="ai-generate-btn" onclick="generateDescription(${sceneIndex}, '${character}', 'hair')">
                                âœ¨ Generate from Tags
                            </button>
                        </div>
                        ${hairTags.length > 0 ? `
                            <div class="detail-tags">
                                Tags: ${hairTags.map(t => `<span class="detail-tag">${t.selectedText}</span>`).join(' ')}
                            </div>
                        ` : ''}
                        <textarea class="detail-textarea" id="hair-${sceneIndex}" rows="2" placeholder="Hair description for breakdown sheet...">${charData.hair || ''}</textarea>
                    </div>

                    <!-- MAKEUP (Beauty) -->
                    <div class="detail-field">
                        <div class="detail-field-header">
                            <label class="detail-label">ðŸ’„ Makeup (Beauty)</label>
                            <button class="ai-generate-btn" onclick="generateDescription(${sceneIndex}, '${character}', 'makeup')">
                                âœ¨ Generate from Tags
                            </button>
                        </div>
                        ${makeupTags.length > 0 ? `
                            <div class="detail-tags">
                                Tags: ${makeupTags.map(t => `<span class="detail-tag">${t.selectedText}</span>`).join(' ')}
                            </div>
                        ` : ''}
                        <textarea class="detail-textarea" id="makeup-${sceneIndex}" rows="2" placeholder="Beauty makeup description...">${charData.makeup || ''}</textarea>
                    </div>

                    <!-- SFX MAKEUP -->
                    <div class="detail-field">
                        <div class="detail-field-header">
                            <label class="detail-label">ðŸ©¸ SFX Makeup</label>
                            <button class="ai-generate-btn" onclick="generateDescription(${sceneIndex}, '${character}', 'sfx')">
                                âœ¨ Generate from Tags
                            </button>
                        </div>
                        ${sfxTags.length > 0 ? `
                            <div class="detail-tags">
                                Tags: ${sfxTags.map(t => `<span class="detail-tag">${t.selectedText}</span>`).join(' ')}
                            </div>
                        ` : ''}
                        <textarea class="detail-textarea" id="sfx-${sceneIndex}" rows="2" placeholder="Wounds, blood, prosthetics, special effects...">${charData.sfx || ''}</textarea>
                    </div>

                    <!-- WARDROBE -->
                    <div class="detail-field">
                        <div class="detail-field-header">
                            <label class="detail-label">ðŸ‘” Wardrobe</label>
                            <button class="ai-generate-btn" onclick="generateDescription(${sceneIndex}, '${character}', 'wardrobe')">
                                âœ¨ Generate from Tags
                            </button>
                        </div>
                        ${wardrobeTags.length > 0 ? `
                            <div class="detail-tags">
                                Tags: ${wardrobeTags.map(t => `<span class="detail-tag">${t.selectedText}</span>`).join(' ')}
                            </div>
                        ` : ''}
                        <textarea class="detail-textarea" id="wardrobe-${sceneIndex}" rows="2" placeholder="Wardrobe description...">${charData.wardrobe || ''}</textarea>
                    </div>

                    <!-- NOTES -->
                    <div class="detail-field">
                        <label class="detail-label">ðŸ“ Notes</label>
                        <textarea class="detail-textarea" id="notes-${sceneIndex}" rows="2" placeholder="Continuity notes, changes from previous scene...">${charData.notes || ''}</textarea>
                    </div>
                </div>
            `;

            // Update prev/next buttons
            updateSceneNavButtons();
        }

        async function generateDescription(sceneIndex, character, category) {
            const btn = event.target;
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner" style="width: 10px; height: 10px; border: 2px solid var(--accent-blue); border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite;"></div> Generating...';

            try {
                // Get tags for this character + category + scene
                const sceneTags = scriptTags[sceneIndex] || [];
                const relevantTags = sceneTags.filter(t =>
                    t.category === category && t.character === character
                );

                if (relevantTags.length === 0) {
                    alert('No tags found for this category. Please tag relevant text in the script first.');
                    return;
                }

                // Collect tag contexts
                const contexts = relevantTags.map(t => t.fullContext).join('\n');
                const tagTexts = relevantTags.map(t => t.selectedText).join(', ');

                const scene = scenes[sceneIndex];
                const categoryNames = {
                    'hair': 'hair styling',
                    'makeup': 'beauty makeup',
                    'sfx': 'SFX makeup (wounds, blood, prosthetics)',
                    'wardrobe': 'wardrobe and costume'
                };

                const prompt = `You are a professional film production breakdown writer. Write a natural, professional description for ${categoryNames[category]} based on these tagged elements from the script.

Tagged elements: ${tagTexts}

Context from script:
${contexts}

Scene: ${scene.heading}
${scene.storyDay ? `Story Day: ${scene.storyDay}` : ''}

Write a concise, specific description suitable for a breakdown sheet. Be practical and actionable for the ${category} department. Use 1-2 sentences maximum.

Examples of good descriptions:
- Hair: "Tied back in loose bun with strands falling out. Windswept appearance."
- Makeup: "Natural, minimal. Slight concealer under eyes. Natural lip color."
- SFX: "Fresh black eye with swelling around left eye. Purple-black bruising, tender to touch."
- Wardrobe: "Blue robe over white cotton nightgown. Barefoot."

IMPORTANT: Respond with ONLY the description text, no JSON, no formatting, just the description.`;

                const description = await callAI(prompt, 200);

                // Populate textarea
                const textarea = document.getElementById(`${category}-${sceneIndex}`);
                if (textarea) {
                    textarea.value = description.trim();
                }

            } catch (error) {
                console.error('AI Description Error:', error);
                alert(`Failed to generate description:\n\n${error.message}`);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'âœ¨ Generate from Tags';
            }
        }

        function previousScene() {
            const selector = document.getElementById('sceneSelector');
            const currentIndex = parseInt(selector.value);
            if (isNaN(currentIndex) || currentIndex <= 0) return;

            // Save current scene data before switching
            saveCastProfileCurrentScene();

            selector.value = currentIndex - 1;
            loadSceneDetails();
        }

        function nextScene() {
            const selector = document.getElementById('sceneSelector');
            const currentIndex = parseInt(selector.value);
            if (isNaN(currentIndex) || currentIndex >= scenes.length - 1) return;

            // Save current scene data before switching
            saveCastProfileCurrentScene();

            selector.value = currentIndex + 1;
            loadSceneDetails();
        }

        function updateSceneNavButtons() {
            const selector = document.getElementById('sceneSelector');
            const currentIndex = parseInt(selector.value);

            document.getElementById('prevSceneBtn').disabled = isNaN(currentIndex) || currentIndex <= 0;
            document.getElementById('nextSceneBtn').disabled = isNaN(currentIndex) || currentIndex >= scenes.length - 1;
        }

        function saveCastProfileCurrentScene() {
            if (!currentCastMember) return;

            const sceneIndex = parseInt(document.getElementById('sceneSelector').value);
            if (!isNaN(sceneIndex)) {
                const scene = scenes[sceneIndex];
                if (!scene.characters) scene.characters = {};
                if (!scene.characters[currentCastMember]) {
                    scene.characters[currentCastMember] = {};
                }

                scene.characters[currentCastMember].hair = document.getElementById(`hair-${sceneIndex}`)?.value || '';
                scene.characters[currentCastMember].makeup = document.getElementById(`makeup-${sceneIndex}`)?.value || '';
                scene.characters[currentCastMember].sfx = document.getElementById(`sfx-${sceneIndex}`)?.value || '';
                scene.characters[currentCastMember].wardrobe = document.getElementById(`wardrobe-${sceneIndex}`)?.value || '';
                scene.characters[currentCastMember].notes = document.getElementById(`notes-${sceneIndex}`)?.value || '';
            }
        }

        // Render continuity events for a character
        function renderContinuityEvents(character) {
            const container = document.getElementById('continuityEventsContainer');
            const events = continuityEvents[character] || [];

            if (events.length === 0) {
                container.innerHTML = `
                    <div class="empty-state-small">
                        <div class="empty-icon-small">âš¡</div>
                        <div class="empty-text-small">No continuity events yet. Click "+ Add Event" to create one.</div>
                    </div>
                `;
                return;
            }

            let html = '';
            events.forEach(event => {
                const eventType = eventTypes.find(t => t.id === event.type) || eventTypes[eventTypes.length - 1];
                const startScene = scenes[event.startScene]?.number || '?';
                const endScene = event.endScene !== null && event.endScene !== undefined
                    ? scenes[event.endScene]?.number || '?'
                    : '?';

                // Get timeline context
                const startDay = scenes[event.startScene]?.storyDay || '';
                const endDay = event.endScene !== null && event.endScene !== undefined
                    ? scenes[event.endScene]?.storyDay || ''
                    : '';
                const timeline = startDay && endDay ? `${startDay} â†’ ${endDay}` : '';

                // Count scenes in range
                const sceneCount = event.endScene !== null && event.endScene !== undefined
                    ? Math.abs(event.endScene - event.startScene) + 1
                    : 1;

                // Calculate overall progress (assuming linear progression)
                const overallProgress = 100; // Full span from start to end
                const midPoint = Math.floor(sceneCount / 2);

                html += `
                    <div class="continuity-event-card">
                        <div class="event-card-header">
                            <div class="event-card-title">
                                <span class="event-card-icon">${eventType.icon}</span>
                                <span>${event.description}</span>
                            </div>
                        </div>

                        <div class="event-card-meta">
                            <div>Scenes ${startScene} â†’ ${endScene} (${sceneCount} scenes)</div>
                            ${timeline ? `<div>${timeline}</div>` : ''}
                        </div>

                        <div class="continuity-progress" style="margin: 12px 0;">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${overallProgress}%;"></div>
                            </div>
                            <div class="progress-label">${sceneCount} scene${sceneCount !== 1 ? 's' : ''}</div>
                        </div>

                        ${event.progression && event.progression.length > 0 ? `
                            <div class="event-card-progression">
                                <div class="event-card-progression-title">Progression</div>
                                ${event.progression.map(stage => `
                                    <div class="event-progression-stage">
                                        â€¢ Sc ${scenes[stage.sceneIndex]?.number || '?'}: ${stage.description}
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}

                        <div class="event-card-actions">
                            <button class="event-action-btn" onclick="editContinuityEvent('${event.id}')">Edit Event</button>
                            <button class="event-action-btn danger" onclick="deleteContinuityEvent('${character}', '${event.id}')">Delete</button>
                            <button class="event-action-btn" onclick="jumpToScene(${event.startScene})">Jump to Scene ${startScene}</button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Render scene-by-scene quick view
        function renderSceneQuickView(character, characterScenes) {
            const container = document.getElementById('scenesQuickView');

            if (characterScenes.length === 0) {
                container.innerHTML = `
                    <div class="empty-state-small">
                        <div class="empty-text-small">Character doesn't appear in any scenes yet.</div>
                    </div>
                `;
                return;
            }

            let html = '';
            characterScenes.forEach(({ scene, index }) => {
                const charData = scene.characters?.[character] || {};
                const sceneTags = scriptTags[index] || [];

                // Get active continuity events for this scene
                const activeEvents = (continuityEvents[character] || []).filter(event => {
                    return event.startScene <= index &&
                           (event.endScene === null || event.endScene === undefined || event.endScene >= index);
                });

                const hasEvents = activeEvents.length > 0;

                // Build details summary
                const details = [];
                if (charData.hair) details.push(`Hair: ${charData.hair}`);
                if (charData.makeup) details.push(`Makeup: ${charData.makeup}`);
                if (charData.sfx) details.push(`SFX: ${charData.sfx}`);
                if (charData.wardrobe) details.push(`Wardrobe: ${charData.wardrobe}`);

                html += `
                    <div class="scene-quick-item ${hasEvents ? 'has-events' : ''}" data-scene-index="${index}">
                        <div class="scene-quick-header">
                            <div class="scene-quick-title">Scene ${scene.number}: ${scene.heading}</div>
                            ${hasEvents ? `
                                <div class="scene-quick-events">
                                    ${activeEvents.map(() => 'âš¡').join('')}
                                    ${activeEvents.length} event${activeEvents.length > 1 ? 's' : ''}
                                </div>
                            ` : ''}
                        </div>

                        ${hasEvents ? `
                            <div style="font-size: 0.75em; color: var(--accent-gold); margin-bottom: 8px;">
                                Active Events: ${activeEvents.map(e => e.description).join(', ')}
                            </div>
                        ` : ''}

                        ${details.length > 0 ? `
                            <div class="scene-quick-details">
                                ${details.join(' | ')}
                            </div>
                        ` : `
                            <div class="scene-quick-details" style="font-style: italic; opacity: 0.6;">
                                No details entered yet
                            </div>
                        `}

                        <div class="scene-quick-actions">
                            <button class="scene-quick-btn" onclick="editSceneDetails(${index}, '${character}')">View/Edit Details</button>
                            <button class="scene-quick-btn" onclick="jumpToScene(${index})">Jump to Scene</button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Jump to scene in script viewer
        function jumpToScene(sceneIndex) {
            closeCastProfile();
            selectScene(scenes[sceneIndex]);

            // Scroll to scene in script
            setTimeout(() => {
                const sceneId = `scene-${scenes[sceneIndex].number}`;
                const sceneElement = document.getElementById(sceneId);
                if (sceneElement) {
                    sceneElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 300);
        }

        // Toggle filter to show only scenes with active events
        let showOnlyEventScenes = false;
        function toggleEventScenes() {
            showOnlyEventScenes = !showOnlyEventScenes;
            const btn = document.getElementById('filterEventsBtn');
            btn.classList.toggle('active', showOnlyEventScenes);
            btn.textContent = showOnlyEventScenes ? 'Show All Scenes' : 'Show Only Event Scenes';

            // Filter scene quick view
            const items = document.querySelectorAll('.scene-quick-item');
            items.forEach(item => {
                if (showOnlyEventScenes) {
                    item.style.display = item.classList.contains('has-events') ? 'block' : 'none';
                } else {
                    item.style.display = 'block';
                }
            });
        }

        // Edit scene details (opens scene-specific editor)
        function editSceneDetails(sceneIndex, character) {
            // Close cast profile modal
            closeCastProfile();

            // Select the scene
            selectScene(scenes[sceneIndex]);

            // Open cast profile again to show scene selector
            // (This would need the old scene-by-scene editor)
            // For now, just jump to the scene
            setTimeout(() => {
                alert(`Editing details for ${character} in Scene ${scenes[sceneIndex].number}.\n\nUse the Scene Breakdown panel to add Hair, Makeup, SFX, and Wardrobe details.`);
            }, 100);
        }

        // Add continuity event (opens existing modal)
        function addContinuityEvent() {
            if (!currentCastMember) return;

            // Close cast profile
            closeCastProfile();

            // Open continuity modal
            currentEventCharacter = currentCastMember;
            currentEditingEvent = null;

            document.getElementById('eventCharacterName').textContent = currentCastMember;
            document.getElementById('eventType').value = 'wound';
            document.getElementById('eventDescription').value = '';
            document.getElementById('eventStartScene').value = currentScene || 0;
            document.getElementById('eventEndScene').value = '';

            document.getElementById('continuityModal').classList.add('active');
        }

        // Edit continuity event
        function editContinuityEvent(eventId) {
            if (!currentCastMember) return;

            const events = continuityEvents[currentCastMember] || [];
            const event = events.find(e => e.id === eventId);
            if (!event) return;

            currentEditingEvent = event;
            currentEventCharacter = currentCastMember;

            // Close cast profile
            closeCastProfile();

            // Open continuity modal with event data
            document.getElementById('eventCharacterName').textContent = currentCastMember;
            document.getElementById('eventType').value = event.type;
            document.getElementById('eventDescription').value = event.description;
            document.getElementById('eventStartScene').value = event.startScene;
            document.getElementById('eventEndScene').value = event.endScene || '';

            document.getElementById('continuityModal').classList.add('active');
        }

        // Delete continuity event
        function deleteContinuityEvent(character, eventId) {
            if (!confirm('Delete this continuity event? This cannot be undone.')) return;

            if (continuityEvents[character]) {
                continuityEvents[character] = continuityEvents[character].filter(e => e.id !== eventId);
                if (continuityEvents[character].length === 0) {
                    delete continuityEvents[character];
                }
            }

            saveProject();
            renderContinuityEvents(character);
        }

        // Initialize
        window.addEventListener('load', init);
    </script>
</body>
</html>
